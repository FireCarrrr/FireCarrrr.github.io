<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YUYUYU&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://firecarrrr.github.io/"/>
  <updated>2019-07-20T08:05:10.337Z</updated>
  <id>https://firecarrrr.github.io/</id>
  
  <author>
    <name>YUYUYU</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL索引(一)</title>
    <link href="https://firecarrrr.github.io/2019/07/20/#MySQL%E7%B4%A2%E5%BC%95/"/>
    <id>https://firecarrrr.github.io/2019/07/20/#MySQL索引/</id>
    <published>2019-07-19T16:00:00.000Z</published>
    <updated>2019-07-20T08:05:10.337Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h1><p>最近在看数据库索引相关的内容，想写成blog，一来整理一下笔记，二来整理一下思路。</p><p>索引的目的是加快数据访问的速度，要实现这个目的需要用到一些高效的数据结构。索引是在存储引擎层实现的，不同的存储引擎可能采用不同的实现方式，用到的数据结构也不尽相同。</p><h2 id="索引的数据结构基础"><a href="#索引的数据结构基础" class="headerlink" title="索引的数据结构基础"></a>索引的数据结构基础</h2><h3 id="B-Tree和B-Tree"><a href="#B-Tree和B-Tree" class="headerlink" title="B-Tree和B+ Tree"></a>B-Tree和B+ Tree</h3><p>MySQL的默认存储引擎InnoDB使用B+ Tree来实现索引，B+ Tree是B-Tree的一个变种，基本上大部分存储引擎都是使用B-Tree类的数据结构来实现索引的。</p><p><strong>为什么要用B-Tree或者B-Tree产生的动机是什么？</strong></p><p>B-Tree本质上是二叉搜索树的一个推广，每一个B-Tree内部节点x有x.n个关键字，这x.n个关键字从小到大依次排列，把关键字分成了x.n+1个区间，那么x就有x.n+1个孩子节点分别存储这些区间范围内的关键字。由于n的数值可以很大，所以B-Tree的树高可以很低，树高低就意味着找到目标需要的随机IO次数少。n的值取多少合适呢？</p><p>我们存储在数据库里的数据，是存储在磁盘上的（也有可能是SSD啦，不过很贵吧），磁盘作为一种依靠磁臂在不同磁道和扇区之间机械运动读取数据的存储装置，与内存和CPU相比就很慢。要加快数据的访问速度那就要减少磁盘IO的次数。磁盘本身存储数据的最小单位是扇区（一般为512 byte），而操作系统的文件系统不是以扇区为单位来读取磁盘的，因为这太慢了，所以有了block（块）的概念，它是一个块一个块的读取的，如果要读取的数据超过一块就会触发多次IO，一个块的大小一般是4K byte。</p><p>一个B-Tree算法的运行时间主要由它执行磁盘读写的时间决定，所以，一个B-Tree节点的大小通常和一个完整的块的大小一样大。因此，磁盘块的大小限制了B-Tree节点可以含有的孩子个数。</p><p>B+ Tree是B-Tree的一个常见变种，B+Tree把所有的卫星数据（除作为键值外的其他数据）都存储在叶子节点里，也就是说非叶节点只存储键值和孩子指针，并且叶子节点之间用指针连接。</p><p><strong>B-Tree由于它的有序性，所以增删节点，维护起来会耗费额外的资源</strong></p><p><strong>所以索引会提高查询效率，但是会降低写入和删除的效率</strong></p><h3 id="Hash表"><a href="#Hash表" class="headerlink" title="Hash表"></a>Hash表</h3><p>hash表没啥可说的，key-value存储方式。需要注意的是，由于hash索引不会按键值顺序存储，所以<strong>hash索引只适用于等值查询的场景，做区间查询会很慢，也没法做部分匹配。</strong></p><h2 id="索引的细节"><a href="#索引的细节" class="headerlink" title="索引的细节"></a>索引的细节</h2><p>下面关于索引的讨论基本上都是针对于MySQL默认存储引擎InnoDB而言的。</p><h3 id="聚簇索引与二级索引"><a href="#聚簇索引与二级索引" class="headerlink" title="聚簇索引与二级索引"></a>聚簇索引与二级索引</h3><p>对于InnoDB而言，聚簇索引其实就是主键索引，在索引的叶子节点中，存储了包含全部数据的数据行。<strong>“聚簇”的意思是说数据行和相邻键值的数据行紧凑的存储在一起（并非一直成立）。</strong></p><p>聚簇索引的实现同样依赖于存储引擎，并非所有存储引擎都支持聚簇索引。聚簇索引的优点显而易见，聚簇索引可以最大限度的提高IO密集型应用的性能。但是这种使用这种精巧的数据结构存储数据都会面临维护上的开销。对于聚簇索引来说：</p><ul><li><p><strong>插入新数据行的速度严重依赖于插入顺序。</strong>按照主键顺序插入到InnoDB表中速度肯定是最快的，非顺序插入不仅慢而且会导致很多磁盘碎片的产生。所以一般尽量用自增主键做主键值，这样在性能上和存储空间上都有优势。</p></li><li><p><strong>更新主键的代价很大。</strong>因为是数据行按主键顺序紧密存储的，所以更新主键就会带来数据行的移动。</p></li><li><p><strong>插入新行（乱序）、主键更新需要移动行时，都可能面临“页分裂（page split）”问题。</strong>当需要把一行插入到一个已满页面的时候，存储引擎会把这个页分裂成两个页来容纳这个行，页分裂操作会导致占用更多磁盘空间，空间利用率降低。</p></li><li><p><strong>聚簇索引会让全表扫描变慢，尤其是行比较稀疏的时候，或者由于页分裂导致数据存储不连续的时候。</strong>这应该是和把所有数据行直接连续存储相比而言的。</p></li></ul><p>二级索引就是指非主键索引，二级索引的叶子节点中除了存储索引列的值之外，还存储了对应行的主键值。这是与MyISAM存储引擎的一个明显的不同，MyISAM索引的叶子节点中存储的时指向数据行的行指针（MyISAM存储引擎按照数据的插入顺序，将数据行存储在磁盘上）。</p><p>InnoDB这种存储主键的方式带来了一个显而易见的好处就是<strong>减少了出现行移动或者数据页分裂时二级索引的维护工作。</strong>也带来了一个显而易见的坏处就是<strong>使用二级索引查询索引不能覆盖的列信息时，需要再到主键索引表回表查询一次。</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="D:\Blog\blog\public\images\innoDB和MyISAM存储方式对比.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h3><p>上面说了，二级索引的叶子节点中只存放索引列的值和主键ID，对于非索引列的查找需要回表。这会带来额外的开销。索引覆盖就是说能不能让索引把查找的target字段全部给包含了。</p><p>当发起一个索引覆盖的查询时，EXPLAIN的Extra列可以看到”Using index”信息。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="D:\Blog\blog\public\images\explain.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>在联合索引中，索引列的顺序对索引的利用率和性能上是有影响的。在一个多列B-Tree索引中，索引列的顺序决定了排序的顺序，越靠左的列排序的优先级越高，也就是说，会先按照第一列排序，在按照第二列排序，以此类推。与此同时，在索引匹配时，是从左往右匹配的。</p><p><strong>所以在建立一个多列的联合索引时应该如何安排索引列的顺序呢？</strong></p><ul><li>最重要的原则就是如果通过调整顺序，可以少维护一个索引，那么这个顺序就是需要优先考虑的。评估的标准就是索引的复用能力。因为支持最左前缀，所以有了(a,b)这个联合索引之后，就不需要在a上建立索引了。</li><li>还有就是考虑空间占用的问题，假如需(name, age)的联合索引，和name和age单独的索引。因为name比age大，所以应该建立(name, age)这个顺序的索引。</li></ul><h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>假设现在有(name,age)联合索引，现在有一个需求：检索出表中名字第一个字是张，而且年龄是10岁的所有男孩</p><p>SQL语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tuser <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'张 %'</span> <span class="keyword">and</span> age=<span class="number">10</span> <span class="keyword">and</span> ismale=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>在这条语句执行时，根据最左前缀匹配原则，这条语句在搜索树的时候只能用到”张“，找到第一个满足条件的记录</p><p>ID3。</p><p>在MySQL 5.6之前，只能从ID3开始一个个回表，到主键索引上找到数据行，再对比字段值。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="D:\Blog\blog\public\images\索引下推1.jpg" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p>在MySQL 5.6引入了索引下推优化(index condition pushdown)，可以再索引遍历过程中，对索引包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表的次数。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="D:\Blog\blog\public\images\索引下推2.jpg" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于索引的东西还有很多，这篇只是一些非常基础的内容。这篇blog拖了好久了，因为这段时间屁事儿太多了，真的很烦。关于索引的坑以后继续填。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL索引&quot;&gt;&lt;a href=&quot;#MySQL索引&quot; class=&quot;headerlink&quot; title=&quot;MySQL索引&quot;&gt;&lt;/a&gt;MySQL索引&lt;/h1&gt;&lt;p&gt;最近在看数据库索引相关的内容，想写成blog，一来整理一下笔记，二来整理一下思路。&lt;/p&gt;
&lt;p&gt;索
      
    
    </summary>
    
      <category term="MySQL" scheme="https://firecarrrr.github.io/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>终于搭好了</title>
    <link href="https://firecarrrr.github.io/2019/06/15/%E7%BB%88%E4%BA%8E%E6%90%AD%E5%A5%BD%E4%BA%86/"/>
    <id>https://firecarrrr.github.io/2019/06/15/终于搭好了/</id>
    <published>2019-06-15T08:48:18.332Z</published>
    <updated>2019-07-20T08:05:06.057Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
