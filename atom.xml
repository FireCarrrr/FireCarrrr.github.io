<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YUYUYU&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://firecarrrr.github.io/"/>
  <updated>2020-07-03T07:34:49.386Z</updated>
  <id>https://firecarrrr.github.io/</id>
  
  <author>
    <name>YUYUYU</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AQS</title>
    <link href="https://firecarrrr.github.io/2020/07/03/AQS/"/>
    <id>https://firecarrrr.github.io/2020/07/03/AQS/</id>
    <published>2020-07-03T07:33:29.000Z</published>
    <updated>2020-07-03T07:34:49.386Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是-AQS"><a href="#什么是-AQS" class="headerlink" title="什么是 AQS?"></a>什么是 AQS?</h1><p><strong>AbstractQueuedSynchronizer</strong> 这个类是许多同步类的基类，是一个用于构建锁和同步器的框架。AQS 解决了在实现同步器时涉及的大量细节问题。 </p><h1 id="AQS-实现"><a href="#AQS-实现" class="headerlink" title="AQS 实现"></a>AQS 实现</h1><h2 id="AQS-框架"><a href="#AQS-框架" class="headerlink" title="AQS 框架"></a>AQS 框架</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="aqs.png" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><h2 id="AQS-原理"><a href="#AQS-原理" class="headerlink" title="AQS 原理"></a>AQS 原理</h2><p>AQS 的核心思想是：</p><ul><li>如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；</li><li>如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。</li></ul><p>这个机制是通过 CLH 队列的变体实现的，将暂时获取不到锁的线程加入队列中。</p><p>AQS 中的队列是一个双向链表，AQS 通过将每条请求共享资源的线程封装成一个节点来实现锁的分配。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="clh.png" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p>AQS 使用一个 Volatile 的 int 类型的成员变量来表示同步状态，通过内置的 FIFO 队列来完成资源获取的排队工作，通过 CAS 操作完成对 State 值的修改。</p><h3 id="AQS-数据结构"><a href="#AQS-数据结构" class="headerlink" title="AQS 数据结构"></a>AQS 数据结构</h3><p>双向链表中的节点：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="node.png" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p><strong>线程有两种锁模式（共享、互斥）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Marker to indicate a node is waiting in shared mode */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line"><span class="comment">/** Marker to indicate a node is waiting in exclusive mode */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p><strong>节点的状态可以是：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Status field, taking on only the values:</span></span><br><span class="line"><span class="comment">*   SIGNAL:     The successor of this node is (or will soon be)</span></span><br><span class="line"><span class="comment">*               blocked (via park), so the current node must</span></span><br><span class="line"><span class="comment">*               unpark its successor when it releases or</span></span><br><span class="line"><span class="comment">*               cancels. To avoid races, acquire methods must</span></span><br><span class="line"><span class="comment">*               first indicate they need a signal,</span></span><br><span class="line"><span class="comment">*               then retry the atomic acquire, and then,</span></span><br><span class="line"><span class="comment">*               on failure, block.</span></span><br><span class="line"><span class="comment">*   CANCELLED:  This node is cancelled due to timeout or interrupt.</span></span><br><span class="line"><span class="comment">*               Nodes never leave this state. In particular,</span></span><br><span class="line"><span class="comment">*               a thread with cancelled node never again blocks.</span></span><br><span class="line"><span class="comment">*   CONDITION:  This node is currently on a condition queue.</span></span><br><span class="line"><span class="comment">*               It will not be used as a sync queue node</span></span><br><span class="line"><span class="comment">*               until transferred, at which time the status</span></span><br><span class="line"><span class="comment">*               will be set to 0. (Use of this value here has</span></span><br><span class="line"><span class="comment">*               nothing to do with the other uses of the</span></span><br><span class="line"><span class="comment">*               field, but simplifies mechanics.)</span></span><br><span class="line"><span class="comment">*   PROPAGATE:  A releaseShared should be propagated to other</span></span><br><span class="line"><span class="comment">*               nodes. This is set (for head node only) in</span></span><br><span class="line"><span class="comment">*               doReleaseShared to ensure propagation</span></span><br><span class="line"><span class="comment">*               continues, even if other operations have</span></span><br><span class="line"><span class="comment">*               since intervened.</span></span><br><span class="line"><span class="comment">*   0:          None of the above</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* The values are arranged numerically to simplify use.</span></span><br><span class="line"><span class="comment">* Non-negative values mean that a node doesn't need to</span></span><br><span class="line"><span class="comment">* signal. So, most code doesn't need to check for particular</span></span><br><span class="line"><span class="comment">* values, just for sign.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* The field is initialized to 0 for normal sync nodes, and</span></span><br><span class="line"><span class="comment">* CONDITION for condition nodes.  It is modified using CAS</span></span><br><span class="line"><span class="comment">* (or when possible, unconditional volatile writes).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br></pre></td></tr></table></figure><ul><li><strong>SIGNAL：</strong>表示当前节点的下一个节点已经被阻塞或者即将被阻塞。因此当前节点释放了锁或者放弃获取锁时，如果它的 waitStatus 是 SIGNAL，它就需要唤醒它的下一个节点。</li><li><strong>CANCELED：</strong>表示 Node 代表的线程因为超时或者中断信号，取消获锁。处于这个状态的 Node 不会再阻塞。</li></ul><h3 id="同步状态-State"><a href="#同步状态-State" class="headerlink" title="同步状态 State"></a>同步状态 State</h3><p>AQS 中维护一个名为 State 的字段，用于展示当前临界资源的获锁情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The synchronization state.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure><p>通过修改 State 字段表示的同步状态来实现多线程的独占模式和共享模式。</p><h1 id="ReentrantLock-的实现"><a href="#ReentrantLock-的实现" class="headerlink" title="ReentrantLock 的实现"></a>ReentrantLock 的实现</h1><h2 id="ReentrantLock-lock-过程"><a href="#ReentrantLock-lock-过程" class="headerlink" title="ReentrantLock#lock 过程"></a>ReentrantLock#lock 过程</h2><p>ReentrantLock 有一个抽象的静态内部类 Sync，Sync 继承自 AbstractQueuedSynchronizer。Sync 有两个子类，NonfairSync 和 FairSync。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Synchronizer providing all implementation mechanics */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Base of synchronization control for this lock. Subclassed</span></span><br><span class="line"><span class="comment">  * into fair and nonfair versions below. Uses AQS state to</span></span><br><span class="line"><span class="comment">  * represent the number of holds on the lock.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br></pre></td></tr></table></figure><p>ReentrantLock 有两个构造器，无参构造器默认构造非公平锁，可以带参构造器来构造公平锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125;.</span></span><br><span class="line"><span class="comment">  * This is equivalent to using &#123;<span class="doctag">@code</span> ReentrantLock(false)&#125;.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the</span></span><br><span class="line"><span class="comment">  * given fairness policy.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当在非公平锁模式下，调用 ReentrantLock#lock 方法时，会被委托给 NonfairSync#lock 执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">  * acquire on failure.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试将 state 由 0 变为 1</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="comment">// 将当前线程设置为独占访问资源的线程</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果状态没有修改成功，应该尝试再去获取锁（可能当前线程已经获锁，实现可重入性）。</span></span><br><span class="line">        <span class="comment">// 如果获锁失败，应该将线程加入等待队列</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NonfairSync#lock 调用 AbstractQueuedSynchronizer#compareAndSetState 以 CAS 方式，试图将 state 从 0 变为 1。</p><p>如果状态改变成功，就将当前线程设置为能够独占访问资源的线程。</p><p>如果状态改变失败，就调用 AbstractQueuedSynchronizer#acquire 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Acquires in exclusive mode, ignoring interrupts.  Implemented</span></span><br><span class="line"><span class="comment">  * by invoking at least once &#123;<span class="doctag">@link</span> #tryAcquire&#125;,</span></span><br><span class="line"><span class="comment">  * returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment">  * repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">  * #tryAcquire&#125; until success.  This method can be used</span></span><br><span class="line"><span class="comment">  * to implement method &#123;<span class="doctag">@link</span> Lock#lock&#125;.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">  *        &#123;<span class="doctag">@link</span> #tryAcquire&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment">  *        can represent anything you like.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果直接尝试去获取资源失败</span></span><br><span class="line">    <span class="comment">// 线程在阻塞队列中获取资源，一直到获取到资源后才返回。如果在等待过程中被中断过，</span></span><br><span class="line">    <span class="comment">// 返回true，否则返回 false</span></span><br><span class="line">    <span class="comment">// 线程会在获取到资源过后再返回，并自我阻塞。</span></span><br><span class="line">    <span class="comment">// 也就是说如果线程被中断了，也会获取资源，并且不会释放。</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>acquire 方法调用的 tryAcquire 实际上会调用 Sync#nonfairTryAcquire，tryAcquire 会再次尝试获取锁。</p><p>AbstractQueuedSynchronizer#addWaiter 会将创建节点，并将节点加入到队列中。</p><p>AbstractQueuedSynchronizer#acquireQueued 再去判断是否可以获得锁。如果不行，修改前驱节点的 waitStatus 为 SIGNAL 然后把线程挂起。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class="line"><span class="comment">  * subclasses, but both need nonfair try for trylock method.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取 state 状态</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 再次尝试将状态改为 1</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实现可重入性</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="comment">// 防止 int 越界？</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Acquires in exclusive uninterruptible mode for thread already in</span></span><br><span class="line"><span class="comment">   * queue. Used by condition wait methods as well as acquire.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted while waiting</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 如果 node 的前驱节点是 head，并且尝试获锁成功</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 把 node 节点设置为头结点</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获锁失败，判断是否需要将当前线程挂起</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Convenience method to park and then check if interrupted</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 线程在这里被挂起，不再执行，直到被唤醒。</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是整个 ReentrantLock 在非公平状态下加锁的过程。</p><ol><li>尝试用 CAS 指令 将 AQS 的 state 由 0 改为 1。</li><li>如果尝试成功，就加锁成功。</li><li>如果尝试失败，会创建节点，并将节点加入到双向链表中。</li><li>将当前线程对应节点的前驱节点的 waitStatus 设置为 SIGNAL，阻塞当前线程。</li><li>前驱节点对应线程在释放锁或者取消获锁时，唤醒后继线程。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="加锁过程.png" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><h2 id="ReentrantLock-unlock-过程"><a href="#ReentrantLock-unlock-过程" class="headerlink" title="ReentrantLock#unlock 过程"></a>ReentrantLock#unlock 过程</h2><p>首先会调用 AQS#release：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Releases in exclusive mode.  Implemented by unblocking one or</span></span><br><span class="line"><span class="comment">  * more threads if &#123;<span class="doctag">@link</span> #tryRelease&#125; returns true.</span></span><br><span class="line"><span class="comment">  * This method can be used to implement method &#123;<span class="doctag">@link</span> Lock#unlock&#125;.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> arg the release argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">  *        &#123;<span class="doctag">@link</span> #tryRelease&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment">  *        can represent anything you like.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the value returned from &#123;<span class="doctag">@link</span> #tryRelease&#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又到 Sync#tryRelease，就是把 state 改成 0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><p>在上面非公平锁的实现中，线程会尝试用 CAS 指令直接去改 state 去获取锁，而不管队列中是都有线程在等待。</p><p>而在公平锁的实现中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Fair version of tryAcquire.  Don't grant access unless</span></span><br><span class="line"><span class="comment">  * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 队列中没有线程或者当前线程就是 head 后面第一个节点时，才会尝试去改状态</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不会像非公平锁中，一上来就 CAS 该状态。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是-AQS&quot;&gt;&lt;a href=&quot;#什么是-AQS&quot; class=&quot;headerlink&quot; title=&quot;什么是 AQS?&quot;&gt;&lt;/a&gt;什么是 AQS?&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;AbstractQueuedSynchronizer&lt;/strong&gt; 这个类是
      
    
    </summary>
    
      <category term="Java" scheme="https://firecarrrr.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>CountDownLatch 和 CyclicBarrier</title>
    <link href="https://firecarrrr.github.io/2020/07/01/CountDownLatch-%E5%92%8C-CyclicBarrier/"/>
    <id>https://firecarrrr.github.io/2020/07/01/CountDownLatch-和-CyclicBarrier/</id>
    <published>2020-07-01T08:09:49.000Z</published>
    <updated>2020-07-01T08:09:49.384Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><blockquote><p>A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.<br>A CountDownLatch is initialized with a given count. The await methods block until the current count reaches zero due to invocations of the countDown method, after which all waiting threads are released and any subsequent invocations of await return immediately. This is a one-shot phenomenon – the count cannot be reset. If you need a version that resets the count, consider using a CyclicBarrier.</p></blockquote><p>CountDownLatch 是一个线程同步的工具，可以使一个或多个线程等待其它线程执行中某些操作执行完成后再执行。</p><p>CountDownLatch 的 await 方法会阻塞到 count 值被减到 0 的时候。</p><p>CountDownLatch 中的计数值，由构造方法中给定的初值初始化。<strong>CountDownLatch 只能被使用一次，count 值不能被重置。</strong></p><p>一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Executor executor = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">executor.execute(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">"World"</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">executor.execute(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello"</span>);</span><br><span class="line">    countDownLatch.countDown();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>两个线程，一个打印 Hello， 一个打印 World，一定要保证先打印 Hello，再打印 World。</p><h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h1><blockquote><p>A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point. CyclicBarriers are useful in programs involving a fixed sized party of threads that must occasionally wait for each other. The barrier is called cyclic because it can be re-used after the waiting threads are released.<br>A CyclicBarrier supports an optional Runnable command that is run once per barrier point, after the last thread in the party arrives, but before any threads are released. This barrier action is useful for updating shared-state before any of the parties continue.</p></blockquote><p>CyclicBarrier 也是一个线程同步工具，允许一组线程等待彼此到达一个共同的 barrier point 。</p><p>当 CyclicBarrier 计数被减到 0 后，所有等待线程被释放后，CyclicBarrier 能够重置到设置的初始值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Executor executor = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">executor.execute(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cyclicBarrier.await();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"World"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">executor.execute(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cyclicBarrier.await();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"World"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>两个线程，打印 Hello World，必须两个线程都打印了 Hello 过后，才能打印 World。</p><p>CyclicBarrier 还有一个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new &#123;<span class="doctag">@code</span> CyclicBarrier&#125; that will trip when the</span></span><br><span class="line"><span class="comment">     * given number of parties (threads) are waiting upon it, and which</span></span><br><span class="line"><span class="comment">     * will execute the given barrier action when the barrier is tripped,</span></span><br><span class="line"><span class="comment">     * performed by the last thread entering the barrier.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parties the number of threads that must invoke &#123;<span class="doctag">@link</span> #await&#125;</span></span><br><span class="line"><span class="comment">     *        before the barrier is tripped</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> barrierAction the command to execute when the barrier is</span></span><br><span class="line"><span class="comment">     *        tripped, or &#123;<span class="doctag">@code</span> null&#125; if there is no action</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> parties&#125; is less than 1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法会创建一个 CyclicBarrier，当指定数目的线程等待它是，它将会触发，当 barrier 触发时，会执行给定的 barrier 操作，由最后一个进入 barrier 的线程执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CountDownLatch&quot;&gt;&lt;a href=&quot;#CountDownLatch&quot; class=&quot;headerlink&quot; title=&quot;CountDownLatch&quot;&gt;&lt;/a&gt;CountDownLatch&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;A synchro
      
    
    </summary>
    
      <category term="Java" scheme="https://firecarrrr.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>TCP 连接的建立和拆除</title>
    <link href="https://firecarrrr.github.io/2020/06/29/TCP-%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B%E5%92%8C%E6%8B%86%E9%99%A4/"/>
    <id>https://firecarrrr.github.io/2020/06/29/TCP-连接的建立和拆除/</id>
    <published>2020-06-29T13:33:21.000Z</published>
    <updated>2020-06-29T13:34:47.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP-连接建立的过程"><a href="#TCP-连接建立的过程" class="headerlink" title="TCP 连接建立的过程"></a>TCP 连接建立的过程</h1><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="三次握手.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ol><li>客户端向服务端发送报文，将 SYN 标志位置 1，客户端随机产生一个初始序列号   client_isn 。</li><li>服务器收到来自客户端的 SYN 报文，<strong>会为该 TCP 连接分配缓存和变量</strong>。服务器向客户端发送确认报文，SYN 标志位置 1，随机生成服务器的初始序列号 server_isn ，将首部确认号字段设置为 client_isn + 1。</li><li>收到服务器的 SYNACK 报文后，<strong>客户端为该连接分配缓存和变量</strong>。客户端向主机发送另一个报文，确认号设置为 server_isn + 1，SYN 设置为 0，序号设置为 client_isn + 1。<strong>这个报文可以携带数据。</strong></li></ol><h3 id="为什么需要三次握手？"><a href="#为什么需要三次握手？" class="headerlink" title="为什么需要三次握手？"></a>为什么需要三次握手？</h3><ul><li>第一次报文发送，服务端如果收到了客户端的报文，此时，服务端知道客户端到服务端的连接是可用的。</li><li>第二次报文发送，如果客户端收到了服务端的报文，此时，客户端知道了客户端到服务端和服务端到客户端的连接时可用的。</li><li>第三次报文发送，如果服务端收到了连接，此时，服务端就知道服务端到客户端的连接也是可用的。客户端和服务端就都能够确认这个链路双向都是可用的。</li></ul><h3 id="为什么客户端和服务端的初始序列号必须随机生成？"><a href="#为什么客户端和服务端的初始序列号必须随机生成？" class="headerlink" title="为什么客户端和服务端的初始序列号必须随机生成？"></a>为什么客户端和服务端的初始序列号必须随机生成？</h3><p>假设有三个角色 A 代表服务器，B 代表客户端，C 代表攻击者。如果以 B 的身份伪造一个请求发送给 A，A 会给 B 发送一个 SYNACK 报文，假设此时 B 被 C 搞得处于异常状态。如果这个 SYNACK 报文中的 server_isn 是固定的，那么 C 就很容易猜测出这个 server_isn，然后构造确认号发送报文给 A。</p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="四次挥手.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>参与一条 TCP 连接的两个进程中任何一个都能终止该连接。当某客户打算关闭连接：</p><ol><li>客户应用进程给服务器发送一个报文，将 FIN 标志位置 1。</li><li>服务器会送一个确认报文，ACK 标志位置 1。</li><li>服务器发送它的终止报文，FIN 标志位置 1。</li><li>客户端对服务器的终止报文进行确认，ACK 置 1。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;TCP-连接建立的过程&quot;&gt;&lt;a href=&quot;#TCP-连接建立的过程&quot; class=&quot;headerlink&quot; title=&quot;TCP 连接建立的过程&quot;&gt;&lt;/a&gt;TCP 连接建立的过程&lt;/h1&gt;&lt;h2 id=&quot;三次握手&quot;&gt;&lt;a href=&quot;#三次握手&quot; class=&quot;
      
    
    </summary>
    
      <category term="Basic" scheme="https://firecarrrr.github.io/categories/Basic/"/>
    
    
      <category term="计算机网络" scheme="https://firecarrrr.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>数据分片与 redis 集群</title>
    <link href="https://firecarrrr.github.io/2020/06/29/redis-%E9%9B%86%E7%BE%A4/"/>
    <id>https://firecarrrr.github.io/2020/06/29/redis-集群/</id>
    <published>2020-06-29T13:32:45.000Z</published>
    <updated>2020-06-29T13:35:24.480Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据分片"><a href="#数据分片" class="headerlink" title="数据分片"></a>数据分片</h1><p>数据分片是分布式存储中最重要的问题之一，即当存储被分散到不同的节点时，如何来将数据映射到不同的节点中？</p><h2 id="顺序分片（范围分片）"><a href="#顺序分片（范围分片）" class="headerlink" title="顺序分片（范围分片）"></a>顺序分片（范围分片）</h2><p>最直观的一种分片方式。假设数据范围是 1<del>100，范围分片就是 1</del>33 落到第一个节点，34<del>66 落到第二个节点，67</del>100 落到第三个节点。</p><p>顺序分片的有点是能做顺序访问</p><p><strong>范围分片的问题：</strong></p><ul><li>面对顺序写的时候可能存在热点</li><li>数据可能是倾斜的，比如总是倾向于访问某个范围内的数据</li></ul><h2 id="Hash-分片"><a href="#Hash-分片" class="headerlink" title="Hash 分片"></a>Hash 分片</h2><p>Hash 分片就是把数据 Hash 一下，然后对节点数量取余得到应该放哪儿。</p><p>Hash 分片最大的问题在于当节点需要拓展时，涉及到大量的数据迁移。</p><h2 id="一致性-Hash"><a href="#一致性-Hash" class="headerlink" title="一致性 Hash"></a>一致性 Hash</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="一致性hash.png" alt="image-20200628221645619" title>                </div>                <div class="image-caption">image-20200628221645619</div>            </figure><p>假设当前有 4 个节点，把这 4 个节点放在一个环上，这个环是从 0 到 hash 函数能够生成的最大值。</p><p>每个键被 hash 后，顺时针查找最近的节点，那这个键就应该落在这个节点上。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="扩容后.png" alt="image-20200628222036769" title>                </div>                <div class="image-caption">image-20200628222036769</div>            </figure><p>假设新增一个节点 5，位于节点 2 和节点 4 之间，可以看到此时，这个变更的影响范围就被局限在了很小的一段上。</p><h2 id="redis-虚拟槽"><a href="#redis-虚拟槽" class="headerlink" title="redis 虚拟槽"></a>redis 虚拟槽</h2><p>redis 集群将整个数据库分成了 16384 个槽（slot）。数据库中的每个键都属于 16384 个槽中的一个，集群中的每个节点可以处理 0 个或者 16384 个槽。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="槽.png" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p>槽是 redis 集群管理数据的基本单位，集群伸缩就是槽和数据在节点之间的移动。</p><h1 id="redis-集群搭建"><a href="#redis-集群搭建" class="headerlink" title="redis 集群搭建"></a>redis 集群搭建</h1><h2 id="cluster-meet"><a href="#cluster-meet" class="headerlink" title="cluster meet"></a>cluster meet</h2><p>首先需要把配置文件里的 cluster-enabled 设置为 yes 以开启集群模式。</p><p>启动节点后，不同机器上的节点之间初跑起来的时候都是独立的，需要通过</p><blockquote><p>cluster meet ip port</p></blockquote><p>命令来使服务器之间握手连接。</p><h2 id="分配槽"><a href="#分配槽" class="headerlink" title="分配槽"></a>分配槽</h2><blockquote><p>cluster addslots [slot]</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据分片&quot;&gt;&lt;a href=&quot;#数据分片&quot; class=&quot;headerlink&quot; title=&quot;数据分片&quot;&gt;&lt;/a&gt;数据分片&lt;/h1&gt;&lt;p&gt;数据分片是分布式存储中最重要的问题之一，即当存储被分散到不同的节点时，如何来将数据映射到不同的节点中？&lt;/p&gt;
&lt;h2 id
      
    
    </summary>
    
    
      <category term="redis" scheme="https://firecarrrr.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 慢查询</title>
    <link href="https://firecarrrr.github.io/2020/06/29/MySQL-%E6%85%A2%E6%9F%A5%E8%AF%A2/"/>
    <id>https://firecarrrr.github.io/2020/06/29/MySQL-慢查询/</id>
    <published>2020-06-29T13:31:56.000Z</published>
    <updated>2020-06-29T13:35:56.678Z</updated>
    
    <content type="html"><![CDATA[<h1 id="获取有性能问题的-SQL"><a href="#获取有性能问题的-SQL" class="headerlink" title="获取有性能问题的 SQL"></a>获取有性能问题的 SQL</h1><h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><p>与慢查询日志有关的配置：</p><ul><li><strong>slow_query_log</strong>：启动停止记录慢查询日志</li><li><strong>slow_query_log_file</strong>：指定慢查询日志存储路径及文件</li><li><strong>long_query_time</strong>：指定记录慢查日志 SQL 执行时间的阈值（单位：秒）</li><li><strong>log_queries_not_using_indexes</strong>：是否记录未使用索引的 SQL（和上面那个阈值无关，只要没有用到索引就会记录）</li></ul><p><strong>慢查询日志中记录的内容：</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="slow_log.png" alt="image-20200629204739096" title>                </div>                <div class="image-caption">image-20200629204739096</div>            </figure><ul><li>执行这条语句的用户信息</li><li>语句执行的时间</li><li>锁的时间</li><li>返回的数据的行数</li><li>扫描的数据的行数</li><li>这条 SQL 语句</li></ul><h2 id="常用慢查询分析工具"><a href="#常用慢查询分析工具" class="headerlink" title="常用慢查询分析工具"></a>常用慢查询分析工具</h2><p>如果是一个繁忙的系统，产生慢查询日志的量可能很大，可以利用一些工具对慢查询日志进行分析。</p><h4 id="mysqldumpslow"><a href="#mysqldumpslow" class="headerlink" title="mysqldumpslow"></a>mysqldumpslow</h4><p>mysqldumpslow 会合并相同的语句</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow -s r -t 10 slow-mysql.log</span><br></pre></td></tr></table></figure><p>-s 指定按哪种排序方式输出结果：</p><ul><li>c：总的执行次数</li><li>t：总的执行时间</li><li>l：总的锁的时间</li><li>r：总的返回的数据行数</li><li>at，al，ar：上面那些值的平均值，</li></ul><p>-t 指定 top 多少条的数据输出</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="mysqldumpslow.png" alt="image-20200629211451977" title>                </div>                <div class="image-caption">image-20200629211451977</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;获取有性能问题的-SQL&quot;&gt;&lt;a href=&quot;#获取有性能问题的-SQL&quot; class=&quot;headerlink&quot; title=&quot;获取有性能问题的 SQL&quot;&gt;&lt;/a&gt;获取有性能问题的 SQL&lt;/h1&gt;&lt;h2 id=&quot;慢查询日志&quot;&gt;&lt;a href=&quot;#慢查询日志&quot; c
      
    
    </summary>
    
      <category term="MySQL" scheme="https://firecarrrr.github.io/categories/MySQL/"/>
    
    
      <category term="SQL" scheme="https://firecarrrr.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>RPC 原理</title>
    <link href="https://firecarrrr.github.io/2020/06/23/RPC-%E5%8E%9F%E7%90%86/"/>
    <id>https://firecarrrr.github.io/2020/06/23/RPC-原理/</id>
    <published>2020-06-23T06:42:08.000Z</published>
    <updated>2020-06-27T07:32:33.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是-RPC"><a href="#什么是-RPC" class="headerlink" title="什么是 RPC"></a>什么是 RPC</h1><p>RPC (Remote Procedure Call)，远程过程调用，也就是一台机器上调用另一台机器上的函数。尽管这两个进程并不在同一个内存空间，但这个调用过程就像发生在一个进程内一样。</p><p>市面上常见的 RPC 框架包括 Dubbo、gRPC 之类的。</p><h2 id="一个-RPC-调用的例子"><a href="#一个-RPC-调用的例子" class="headerlink" title="一个 RPC 调用的例子"></a>一个 RPC 调用的例子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Reference</span> <span class="comment">// dubbo注解</span></span><br><span class="line">    <span class="keyword">private</span> HelloService helloService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> helloService.hello(<span class="string">"World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端</span></span><br><span class="line"><span class="meta">@Service</span> <span class="comment">// dubbo注解</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是一个 Spring 和 Dubbo 配合使用的例子。 </p><p>客户端通过 @ Reference 注解，获取了一个 HelloService 接口的对象。然后就可以直接调用 HelloService 的方法，但实际上这个调用的实现发生在远程主机。</p><p>在服务端，实现了 HelloService 接口，并使用 @Service 注解（dubbo 注解），在 Dubbo 框架中注册了这个实现类。</p><p>可以看出，在业务编码层面上，使用 dubbo 实现远程调用和在本地调用并没有多大区别，这是因为 dubbo 框架在背后完成了远程调用。</p><p>在客户端，业务代码得到的 HelloService 这个接口的实现，并不是服务端提供的真正的实现类 HelloServiceImpl 的一个实例，<strong>而是由 RPC 框架提供的一个代理类的实例，这个代理类被称作 ”桩（stub）“。</strong></p><p>作为一个代理类，桩也实现了 HelloService 接口，客户端在调用 hello 方法时，实际上调用的是这个桩的 hello 方法。在这个 hello 方法中，桩会构造一个请求，包含：</p><ul><li>请求的服务名，例如：HelloService#hello(String)</li><li>请求的所有参数，比如例子中的 name，值是 “World”</li></ul><p>服务端收到请求后，先把请求中的服务名解析出来，然后根据服务名在服务端进程中，找到服务的提供者。找到提供者后，RPC 框架使用客户端传来的参数调用服务提供者。服务端的 RPC 框架获得返回结果之后，再将结果封装成响应，返回给客户端。</p><p>客户端收到服务端的响应后，从中解析出返回值，返回给服务调用方。这样一次 RPC 调用就完成了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="D:\Blog\blog\source\_posts\RPC-原理\demo.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="RPC-主要技术"><a href="#RPC-主要技术" class="headerlink" title="RPC 主要技术"></a>RPC 主要技术</h2><p>实现一个 RPC 框架，主要需要实现：</p><ol><li>高性能网络传输</li><li>序列化与反序列化</li><li>服务路由与服务发现</li></ol><p>关于服务路由与服务发现：</p><p>​       这个模块要解决的是，客户端如何知道服务端的服务地址呢？在 RPC 框架中存在一个<strong>注册中心</strong>组件，服务端的业务代码在向 RPC 框架注册服务之后，RPC 框架就会把这个服务的名称和地址发布到注册中心上。客户端的桩在调用服务之前，会向注册中心请求服务端的地址。</p><h2 id="RPC-框架的一个-Demo"><a href="#RPC-框架的一个-Demo" class="headerlink" title="RPC 框架的一个 Demo"></a>RPC 框架的一个 Demo</h2><p>这个类里面定义了 RPC 里面最重要的几个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RPC框架对外提供的服务接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RpcAccessPoint</span> <span class="keyword">extends</span> <span class="title">Closeable</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 客户端获取远程服务的引用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uri 远程服务地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceClass 服务的接口类的Class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 服务接口的类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 远程服务引用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getRemoteService</span><span class="params">(URI uri, Class&lt;T&gt; serviceClass)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务端注册服务的实现实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> service 实现实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceClass 服务的接口类的Class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 服务接口的类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 服务地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function">URI <span class="title">addServiceProvider</span><span class="params">(T service, Class&lt;T&gt; serviceClass)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取注册中心的引用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nameServiceUri 注册中心URI</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 注册中心引用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> NameService <span class="title">getNameService</span><span class="params">(URI nameServiceUri)</span> </span>&#123;</span><br><span class="line">        Collection&lt;NameService&gt; nameServices = ServiceSupport.loadAll(NameService.class);</span><br><span class="line">        <span class="keyword">for</span> (NameService nameService : nameServices) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nameService.supportedSchemes().contains(nameServiceUri.getScheme())) &#123;</span><br><span class="line">                nameService.connect(nameServiceUri);</span><br><span class="line">                <span class="keyword">return</span> nameService;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务端启动RPC框架，监听接口，开始提供远程服务。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 服务实例，用于程序停止的时候安全关闭服务。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Closeable <span class="title">startServer</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是-RPC&quot;&gt;&lt;a href=&quot;#什么是-RPC&quot; class=&quot;headerlink&quot; title=&quot;什么是 RPC&quot;&gt;&lt;/a&gt;什么是 RPC&lt;/h1&gt;&lt;p&gt;RPC (Remote Procedure Call)，远程过程调用，也就是一台机器上调用另一台机器
      
    
    </summary>
    
      <category term="Distributed System" scheme="https://firecarrrr.github.io/categories/Distributed-System/"/>
    
    
  </entry>
  
  <entry>
    <title>java String</title>
    <link href="https://firecarrrr.github.io/2020/06/22/java-String/"/>
    <id>https://firecarrrr.github.io/2020/06/22/java-String/</id>
    <published>2020-06-22T07:20:05.000Z</published>
    <updated>2020-06-22T08:21:26.384Z</updated>
    
    <content type="html"><![CDATA[<h1 id="String-对象是如何实现的"><a href="#String-对象是如何实现的" class="headerlink" title="String 对象是如何实现的"></a>String 对象是如何实现的</h1><h2 id="JDK-7-amp-8-的实现"><a href="#JDK-7-amp-8-的实现" class="headerlink" title="JDK 7 &amp; 8 的实现"></a>JDK 7 &amp; 8 的实现</h2><p>在这两个版本的 JDK 中，String 本质上是一个不可变 char[]</p><h2 id="JDK-9-的实现"><a href="#JDK-9-的实现" class="headerlink" title="JDK 9 的实现"></a>JDK 9 的实现</h2><p>JDK 9 中，char[] 被改变成了 byte[]。并且新增了一个属性 coder，来表示编码格式。这是因为一个 char 字符占两个字节，在可变长编码格式中，对于只占一个字节的字符来说，相当于浪费了一个字节的空间。用 byte[] 字符和编码格式标记的组合可以提高空间利用率。</p><h2 id="String-对象的不可变性"><a href="#String-对象的不可变性" class="headerlink" title="String 对象的不可变性"></a>String 对象的不可变性</h2><p>String 这个类本身被标记为 final，表示这个类不可继承。底层的存储数组也被标记为 private final 表示不可修改。也就是说 String 对象一旦被创建成功就不能被修改了。</p><h3 id="为什么-String-对象要被设计为不可变的？"><a href="#为什么-String-对象要被设计为不可变的？" class="headerlink" title="为什么 String 对象要被设计为不可变的？"></a>为什么 String 对象要被设计为不可变的？</h3><ul><li>使得 hash 值不会变更，这使得 String 类型非常适合用来做 HashMap 的 key。</li><li>可以实现字符串常量池。</li></ul><h1 id="三种创建-String-的方式"><a href="#三种创建-String-的方式" class="headerlink" title="三种创建 String 的方式"></a>三种创建 String 的方式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"abc"</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">String str3 = str2.intern();</span><br></pre></td></tr></table></figure><h2 id="String-str1-“abc”"><a href="#String-str1-“abc”" class="headerlink" title="String str1 = “abc”;"></a>String str1 = “abc”;</h2><p>使用这种方式创建字符串，JVM 首先会检查该对象是否在<strong>字符串常量池中，如果在，就返回该对象的引用</strong>。否则，就会在字符串常量池中创建新的字符串。这种方式可以减少同一值的字符串对象被重复创建，节约内存。</p><h2 id="String-str2-new-String-“abc”"><a href="#String-str2-new-String-“abc”" class="headerlink" title="String str2 = new String(“abc”);"></a>String str2 = new String(“abc”);</h2><p>用这种方式创建字符串，首先在编译类文件的时候，“abc” 常量字符会被放到常量结构中。在类加载时，“abc” 将会在常量池中创建。在 new 方法被调用时，JVM 会在堆上创建一个 String 对象，String 中的数组会引用常量池中的 “abc” 对应的数组。然后 str2 会指向堆内存上这个对象的引用。</p><h2 id="String-str3-str2-intern-；"><a href="#String-str3-str2-intern-；" class="headerlink" title="String str3 = str2.intern()；"></a>String str3 = str2.intern()；</h2><p>如果调用 intern 方法，会先去查看字符串常量池中是否有等于该对象字符串的引用。如果有，就会返回常量池中这个字符串的引用，如果没有，就会在把这个字符串添加到常量池中。最终这个 str3 会指向常量池中的字符串引用。</p><h2 id="一道题"><a href="#一道题" class="headerlink" title="一道题"></a>一道题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1 == str2;</span><br><span class="line">str2 == str3;</span><br><span class="line">str1 == str3;</span><br></pre></td></tr></table></figure><p>答案应该是，false，false，true</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;String-对象是如何实现的&quot;&gt;&lt;a href=&quot;#String-对象是如何实现的&quot; class=&quot;headerlink&quot; title=&quot;String 对象是如何实现的&quot;&gt;&lt;/a&gt;String 对象是如何实现的&lt;/h1&gt;&lt;h2 id=&quot;JDK-7-amp-8-的
      
    
    </summary>
    
      <category term="Java" scheme="https://firecarrrr.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Gap Lock</title>
    <link href="https://firecarrrr.github.io/2020/06/21/Gap-Lock/"/>
    <id>https://firecarrrr.github.io/2020/06/21/Gap-Lock/</id>
    <published>2020-06-21T06:39:06.000Z</published>
    <updated>2020-06-21T09:32:06.513Z</updated>
    
    <content type="html"><![CDATA[<h1 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h1><p>幻读是指一个事务在进行过程中前后两次对同一范围数据的查询结果不一致，后一次出现了前一次查询没有查到的新行。这个新行指的是被新插入的新行。</p><p>幻读只会出现在 rr 隔离级别下的当前读场景，因为在 rc 隔离级别下，语义上规定的就是一个事务提交了就能被其它事务看到，就无所谓什么幻读了。</p><h1 id="快照读与当前读"><a href="#快照读与当前读" class="headerlink" title="快照读与当前读"></a>快照读与当前读</h1><h2 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h2><p>在 MySQL 的默认隔离级别 RR 下，一般的 select 语句完成的是基于 MVCC 实现的快照读，自然不会出现幻读的问题。</p><h2 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h2><p>当前读是指加锁的读取和 DML 操作。例如，使用下面两条查询语句可以实现当前读：</p><ul><li><strong>select … for share (for share mode)</strong> ：这条语句是给 select 查询到的行加上读锁，其它的事务可以读到这些行，但是没办法修改，直到你的事务提交。（走全表扫描也是会被锁所有行的）。如果你执行这条语句的时候，还有其它未提交的事务对这些行进行了修改，那么你的查询就必须等到那些事务提交过后再执行。</li><li><strong>select … for update</strong>：这条语句给查询中遇到的行加上排它锁，也就是说如果走全表扫描，整个表的行都会被锁。其它事务如果在这些语句上执行更新操作或者 select … for share 会被阻塞。在某些隔离级别下读这些数据也会被阻塞。（RR 隔离级别会忽略 read view 上出现的任何记录上的锁）。</li></ul><h1 id="幻读的问题"><a href="#幻读的问题" class="headerlink" title="幻读的问题"></a>幻读的问题</h1><p>创建一个表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`d`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`c`</span> (<span class="string">`c`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),</span><br><span class="line">(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure><p>有 id 和 c, d 三行。id 是主键，c 上加了索引。</p><p><strong>如果 for update 只在 id = 5 这一行加锁：</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="example.png" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><ol><li><p>T1 时刻，把所有 d = 5 的行加锁。查询结果应该是 (5,5,5)</p></li><li><p>T2 时刻，id = 0 的那一行数据，变成了 (0,5,5)</p></li><li><p>T3 时刻，查询结果应该是 (0,5,5)，(5,5,5)</p></li><li><p>T4 时刻，插入了一条数据 (1,1,5)，又改成了（1,5,5）</p></li><li><p>T5 时刻，查询结果是 (0,5,5), (1,5,5), (5,5,5)</p></li></ol><p>分析一下：</p><ul><li>T1 时刻，session A 给 id = 5 这一行加了锁，并没有给 id = 0 这一行加锁，所以 T2 这个 update 语句可以执行。这样就破坏了<strong>seesion A 给所有 d = 5 的行加锁的语义。</strong></li><li>同样的道理，session C 也破坏了 session A 的加锁语义。</li></ul><p>所以幻读会造成<strong>语义上的问题</strong>。</p><p>幻读还可能造成<strong>数据一致性</strong>上的问题。数据一致性包括数据库内部数据状态的一致性还包括数据和日志在逻辑上的一致性。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="example3.png" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><ol><li>T1 时刻，id = 5 这一行变成了 (5,5,100)，这个结果最终在 T6 时刻正式提交。</li><li>T2 时刻，id = 0 这一行变成了 (0,5,5)。</li><li>T4 时刻，表中多了一行 (1,5,5)。</li></ol><p>看一下 binlog 中的内容</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* T2 时刻 session B 提交 */</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d=<span class="number">5</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">0</span>; <span class="comment">/*(0,0,5)*/</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c=<span class="number">5</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">0</span>; <span class="comment">/*(0,5,5)*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* T4 时刻 session C 提交 */</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>); <span class="comment">/*(1,1,5)*/</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c=<span class="number">5</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>; <span class="comment">/*(1,5,5)*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* T6 时刻 session A 提交 */</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d=<span class="number">100</span> <span class="keyword">where</span> d=<span class="number">5</span>;<span class="comment">/*所有d=5的行，d改成100*/</span></span><br></pre></td></tr></table></figure><p>显然，通过这个 binlog 去恢复一个库或者克隆一个库，运行的结果都是和库里的数据不一致的。</p><p>即便是我们在 T1 时刻把扫描范围内遇到的行都加上锁，Session B 会被阻塞，但是 Session C 的插入语句，由于被插入语句还不存在，不存在的语句没法加锁，也就是说可以插入成功和修改成功，这样 binlog 里的顺序变成了 Session C -&gt; Session A -&gt; Session B。这样用 binlog 去恢复一个库，Session B 的执行结果没问题了，Session C 的结果还是会变成 (1,5,100)。这就是<strong>幻读导致的问题</strong>。</p><h1 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h1><p>产生幻读的原因是行锁只能锁住已经存在的行，而插入操作是在已经存在数据的”间隙“做的操作。</p><p>比如上面例子的表中，最开始插入了 6 条数据，在表的主键索引上就形成了 7 个间隙。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="gap.png" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p>这样在执行 select * from t where d = 5 for update 的时候，就不止给数据库中已经有的 6 个记录加锁（d 上没有索引，走全表扫描），还需要同时加 7 个间隙锁。这样就能确保无法插入新的记录。</p><p>也就是说不仅给行加上了行锁，还给<strong>行两边的间隙</strong>加上了间隙锁。</p><p>间隙锁锁定的是<strong>其他事务往这个间隙中插入记录</strong>这个操作。</p><p>间隙锁和行锁合成为 <strong>next-key lock</strong></p><p>next-key-lock 是一个前开后闭的区间</p><p>我们的表 t 初始化以后，如果用 select * from t for update 要把整个表所有记录锁起来，就形成了 7 个 next-key lock，分别是 (-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, +supremum]。</p><h2 id="间隙锁可能导致的问题"><a href="#间隙锁可能导致的问题" class="headerlink" title="间隙锁可能导致的问题"></a>间隙锁可能导致的问题</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="D:\Blog\blog\source\_posts\Gap-Lock\gaplockpro.png" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><ol><li>Session A 启动事务，由于 id = 9 这一行不存在，加上一个 (5, 10) 的间隙锁。</li><li>Session B 启动，同样加了一个 (5, 10) 的间隙锁。</li><li>Session B 执行 insert 语句，被 Session A 的间隙锁拦住。</li><li>Session A 执行 insert 语句，被 Session B 的间隙锁拦住。</li><li>形成死锁。</li></ol><p>间隙锁增大了锁的范围，会降低并发度。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;幻读&quot;&gt;&lt;a href=&quot;#幻读&quot; class=&quot;headerlink&quot; title=&quot;幻读&quot;&gt;&lt;/a&gt;幻读&lt;/h1&gt;&lt;p&gt;幻读是指一个事务在进行过程中前后两次对同一范围数据的查询结果不一致，后一次出现了前一次查询没有查到的新行。这个新行指的是被新插入的新行。&lt;/
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://firecarrrr.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL日志</title>
    <link href="https://firecarrrr.github.io/2020/06/19/MySQL%E6%97%A5%E5%BF%97/"/>
    <id>https://firecarrrr.github.io/2020/06/19/MySQL日志/</id>
    <published>2020-06-19T12:48:35.000Z</published>
    <updated>2020-06-20T09:33:53.768Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL-日志"><a href="#MySQL-日志" class="headerlink" title="MySQL 日志"></a>MySQL 日志</h1><p>总结一下 MySQL （innoDB 存储引擎）的三种日志。</p><ul><li><strong>redo log</strong>：InnoDB 特有的物理日志</li><li><strong>bin log</strong>：Server 层的逻辑日志</li><li><strong>undo log</strong>：存放数据被修改前的值</li></ul><h2 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h2><p>Buffer Pool 是 InnoDB 在内存中缓存被访问表和索引的地方。Buffer Pool 可以使得经常被访问的数据直接在内存中被处理，从而加快处理速度。缓冲池以页为单位来缓存数据，在 InnoDB 中每个数据页的大小默认是 16 KB。缓冲池的实现本质上就是数据页的一个链表，通过一个变种的 LRU 算法淘汰数据页。</p><h3 id="Change-Buffer"><a href="#Change-Buffer" class="headerlink" title="Change Buffer"></a>Change Buffer</h3><p>change buffer 是 buffer pool 的一部分，用来对非唯一索引的更新操作（Insert、Update、Delete）进行缓存的数据结构。由于缓存了，就不用立马访存写盘，进行大量的随机 IO 操作。</p><p><strong>什么时候写 change buffer？</strong></p><p>更新操作作用的数据页没有在 buffer pool 中，就把更新操作缓存到 change buffer 中。</p><p><strong>什么时候 merge 数据？</strong><br>当之后发生更新操作的页因为读操作被加载到内存中后。</p><h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p>redo log 是 InnoDB 引擎特有的日志，是一种物理日志，记录的是“在某个数据页做了什么修改”。</p><p>MySQL 有一项叫做 <strong>WAL (Write-Ahead Logging)</strong>，也就是预写日志技术。</p><p>当有记录需要更新时，InnoDB 会把更新记录写到 redo log 中，并更新内存（写读到 buffer pool 中的数据或者写 change buffer），这个更新操作就算完成了。之后系统会在适当的时间点将更新记录刷到磁盘上。</p><p><strong>如果 buffer 中的数据还没有刷到磁盘上，系统就发生了崩溃或者断电怎么办？</strong></p><p>redo log 另外一个重要功能就是能够使系统具有 <strong>crash-safe</strong> 能力。redo log 同样在内存中存在缓存，存在先写缓存后写磁盘的问题，可以通过 innodb_flush_log_at_trx_commit  参数设置写磁盘的时机。默认值1代表每次事务提交时，都会写到磁盘。</p><p>在实现上，redo log 是固定大小的，用两个指针来表明写文件的起点和终点：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="redo-log.png" alt="redo-log.png" title>                </div>                <div class="image-caption">redo-log.png</div>            </figure><p>如上图所示，write pos 代表当前可写的位置，checkpoint 是当前要擦除的位置。如果 write pos 追上了 checkpoint ，代表 redo log 已经写满了，这时候新的更新语句不能够再执行，需要停下来先擦掉一些数据，把 checkpoint 向前推进一些，腾出可写空间。</p><p><strong>如何推进 checkpoint ？</strong></p><p>如果 checkpoint 被触发后，会将 buffer 中的脏数据都刷到磁盘上，这样就能保证，即时删除 redo log 上的记录也不会发生数据丢失。</p><h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><p>binlog 是 MySQL Server 层的日志，是逻辑日志，记录的是这个语句的原始逻辑，例如”给 ID = 1 这行的字段 c 加 1“。</p><p>binlog 有三种格式：</p><ul><li>statement：记录 sql 语句</li><li>row：记录行的内容，更新前和后都有</li><li>mixed：默认用 statement，特定的时候转换为 row</li></ul><p>在数据更新时，redo log 和 binlog 都会用到，下面看一下一条更新语句的执行过程。</p><p>更新语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">Test</span> <span class="keyword">set</span> a = <span class="number">1</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="update.png" alt="update.png" title>                </div>                <div class="image-caption">update.png</div>            </figure><p>在写 redo log 时采用了两阶段提交，为的是避免通过 redo log 恢复数据和通过 binlog 恢复数据出现不一致。如果先写 redo log，然后系统崩了，那么通过 binlog 恢复的数据就会少一个操作。反之，通过 redo log 恢复，就会少一个操作。</p><p>与 redo log 的循环写模式不同，binlog 采用追加写的模式。也就是说只要空间足够大，对数据库的所有操作，都可以被 binlog 记录下来。</p><p><strong>如何把数据库恢复到半个月内任意一秒？</strong></p><ul><li>定期做系统的整库备份。</li><li>找到离要恢复时间点最近的一次备份，利用备份中的 binlog ，重放到要恢复的时间点。</li></ul><p>同样可以通过参数 sync_binlog 来设置 binlog 的持久化策略。设置为1表示每次事务都持久化。</p><h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><p>undo log 即回滚日志，是 InnoDB 引擎提供的逻辑日志。当事务对数据库进行修改操作时，InnoDB 不仅会记录 redo log，还会生成 undo log；如果事务执行失败或者调用 rollback，导致事务回滚时，就可以利用 undo log 中的信息将数据回滚到修改之前的样子。</p><p>undo log 主要实现两个功能：</p><ul><li>事务回滚</li><li>MVCC</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL-日志&quot;&gt;&lt;a href=&quot;#MySQL-日志&quot; class=&quot;headerlink&quot; title=&quot;MySQL 日志&quot;&gt;&lt;/a&gt;MySQL 日志&lt;/h1&gt;&lt;p&gt;总结一下 MySQL （innoDB 存储引擎）的三种日志。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;s
      
    
    </summary>
    
      <category term="MySQL" scheme="https://firecarrrr.github.io/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring 事务的传播行为</title>
    <link href="https://firecarrrr.github.io/2020/06/18/Transaction/"/>
    <id>https://firecarrrr.github.io/2020/06/18/Transaction/</id>
    <published>2020-06-18T14:14:06.000Z</published>
    <updated>2020-06-19T03:55:49.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-事务传播行为"><a href="#Spring-事务传播行为" class="headerlink" title="Spring 事务传播行为"></a>Spring 事务传播行为</h1><h2 id="什么是-Spring-事务传播行为？"><a href="#什么是-Spring-事务传播行为？" class="headerlink" title="什么是 Spring 事务传播行为？"></a>什么是 Spring 事务传播行为？</h2><p>Spring 事务传播行为是指被声明为事务的方法，嵌套到另一个方法时，事务是如何传播的。</p><h2 id="Spring-事务的传播行为有哪些？"><a href="#Spring-事务的传播行为有哪些？" class="headerlink" title="Spring 事务的传播行为有哪些？"></a>Spring 事务的传播行为有哪些？</h2><p>通过实验的方式来验证一下 Spring 事务的传播行为。</p><p>将就用一下之前项目中的用户表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`nickname`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8mb4_bin <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`password`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_bin <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'两次 MD5'</span>,</span><br><span class="line">  <span class="string">`salt`</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">COLLATE</span> utf8mb4_bin <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`head`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8mb4_bin <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`register_time`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`last_login_time`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`login_count`</span> <span class="built_in">int</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`mobile`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8mb4_bin <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">2</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COLLATE</span>=utf8mb4_bin;</span><br></pre></td></tr></table></figure><ol><li><strong>PROPAGATION_REQUIRED</strong></li></ol><p>定义了两个方法，一个正常执行，一个抛一个异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span>(propagation = Propagation.REQUIRED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setNickname(<span class="string">"小王"</span>);</span><br><span class="line">    userMapper.insert(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span>(propagation = Propagation.REQUIRED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUserException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setNickname(<span class="string">"小李"</span>);</span><br><span class="line">    userMapper.insert(user);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个外围方法，外围方法不带事务，外围方法中，分别调用这两个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUserTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    propaTestService.addUser();</span><br><span class="line">    propaTestService.addUserException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><ul><li>小王插入成功，小李插入失败</li></ul><p>也就是说，两个内部方法各自执行了自己的事务。第二个方法的回滚没有对第一个方法造成影响。</p><p>再定义一个外围方法，外围方法声明事务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUserTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    propaTestService.addUser();</span><br><span class="line">    propaTestService.addUserException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><ul><li>小王和小李都插入失败</li></ul><p>也就是说，两个内部方法处于一个事务之中，方法2的执行抛出异常造成了两个方法的回滚。</p><p>总结一下 REQUIRED 的事务传播行为：</p><p><strong>如果当前方法有事务，就用当前方法的事务。如果没有，就用自身的事务</strong></p><ol start="2"><li><strong>PROPAGATION_SUPPORTS</strong></li></ol><p>外围方法没有事务的情况：</p><ul><li>小王和小李都插入成功</li></ul><p>外围方法有事务的情况：</p><ul><li>小王和小李都插入失败</li></ul><p>SUPPORTS 的事务传播行为：</p><p><strong>事务可有可无，如果当前方法有事务，就以当前外部事务执行，如果没有事务，就以非事务的方式执行</strong></p><ol start="3"><li><strong>PROPAGATION_MANDATORY</strong></li></ol><p>外围方法没有事务的情况：</p><ul><li>插入失败，并且抛出异常 </li></ul><blockquote><p>org.springframework.transaction.IllegalTransactionStateException: No existing transaction found for transaction marked with propagation ‘mandatory’</p></blockquote><p>外围方法有事务的情况：</p><ul><li>都插入失败</li></ul><p>MANDATORY 的事务传播行为：</p><p><strong>事务是必须的，外围方法没有事务就会抛异常，有事务就以当前事务执行</strong></p><ol start="4"><li><strong>PROPAGATION_REQUIRES_NEW</strong></li></ol><p>外围方法没有事务的情况：</p><ul><li>小王插入成功，小李插入失败</li></ul><p>外围方法有事务的情况：</p><ul><li>小王插入成功，小李插入失败</li></ul><p>REQUIRES_NEW 的传播行为：</p><p><strong>无论外围方法有没有事务，都会新开内部方法自己的事务，且事务之间互不影响</strong></p><ol start="5"><li><strong>PROPAGATION_NOT_SUPPORTED</strong></li></ol><p>外围方法没有事务的情况：</p><ul><li>小王、小李都插入成功</li></ul><p>外围方法有事务的情况：</p><ul><li>小王、小李都插入成功</li></ul><p>NOT_SUPPORT 的传播行为：</p><p><strong>不支持事务，以非事务的方式执行</strong></p><ol start="6"><li><strong>PROPAGATION_NEVER</strong></li></ol><p>外围没有事务：</p><ul><li>都插入成功</li></ul><p>外围有事务：</p><ul><li>抛异常</li></ul><p>NEVER 的传播行为：</p><p><strong>不支持事务，有事务就抛异常</strong></p><ol start="7"><li><strong>PROPAGATION_NESTED</strong></li></ol><p>外围没有事务：</p><ul><li>小王插入成功，小李插入失败</li></ul><p>外围有事务：</p><ul><li>都插入失败</li></ul><p>现在看来和 REQUIRED 的行为很像，来看第三种情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUserTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    propaTestService.addUser();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        propaTestService.addUserException();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">"回滚"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下，外部方法中把内部方法抛出的异常 catch 了，这样得到的结果是：</p><ul><li>小王插入成功，小李插入失败</li></ul><p>NESTED 的传播行为：</p><p><strong>如果外围方法有事务，内部方法会启动子事务，如果外部事务没有感知到子事务抛出的异常，可以只回滚子事务</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring-事务传播行为&quot;&gt;&lt;a href=&quot;#Spring-事务传播行为&quot; class=&quot;headerlink&quot; title=&quot;Spring 事务传播行为&quot;&gt;&lt;/a&gt;Spring 事务传播行为&lt;/h1&gt;&lt;h2 id=&quot;什么是-Spring-事务传播行为？&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="Java" scheme="https://firecarrrr.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Dynamic Proxy</title>
    <link href="https://firecarrrr.github.io/2020/05/07/Dynamic-Proxy/"/>
    <id>https://firecarrrr.github.io/2020/05/07/Dynamic-Proxy/</id>
    <published>2020-05-07T10:14:40.000Z</published>
    <updated>2020-05-07T14:42:37.738Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p><strong>代理模式（Proxy Design Pattern）：</strong>在不改变原始类的情况下，通过代理类来给原始类添加功能。被代理类中实现的是主要的业务逻辑，代理类在主要业务逻辑的基础上加上了一些额外的与主业务逻辑关系不大的功能，比如说做一些统计、日志等。</p><p>代理模式可以通过<strong>静态</strong>也可以通过<strong>动态</strong>的方式实现。</p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>下面是一个静态代理的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个接口，包含登录和注册方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 业务类实现登录和注册逻辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="keyword">implements</span> <span class="title">IUserController</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"login"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"register"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代理类继承同一个接口，将具体登录行为委托给业务类实现，在业务逻辑上加上自身代理的逻辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserControllerProxy</span> <span class="keyword">implements</span> <span class="title">IUserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserController userController;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserControllerProxy</span><span class="params">(UserController userController)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userController = userController;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// doSomething1()</span></span><br><span class="line">        userController.login();</span><br><span class="line">        <span class="comment">// doSomething2()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// doSomething1()</span></span><br><span class="line">        userController.register();</span><br><span class="line">        <span class="comment">// doSomething2()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态构建代理类在复杂的业务场景下会使类的数量大幅增加，引入大量额外工作，代码重复较多，不够简洁。动态代理可以用来解决这个问题。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>动态代理的实现主要有两种 JDK 的实现和 cglib 的实现。</p><h3 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h3><p><strong>JDK 实现中有一个接口：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.reflect.InvocationHandler</span><br></pre></td></tr></table></figure><p>Java doc 里面这样描述这个接口：</p><blockquote><p>InvocationHandler is the interface implemented by the invocation handler of a proxy instance.<br>Each proxy instance has an associated invocation handler. When a method is invoked on a proxy instance, the method invocation is encoded and dispatched to the invoke method of its invocation handler.</p></blockquote><p>InvacationHandler 接口被代理实例的 invocation handler 实现。每一个代理实例都有一个关联的 invocation handler。当代理对象上有方法被调用时，将对方法进行编码，并分派到调用程序的 invoke 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable</span>;</span><br></pre></td></tr></table></figure><blockquote><p>Processes a method invocation on a proxy instance and returns the result. This method will be invoked on an invocation handler when a method is invoked on a proxy instance that it is associated with.</p></blockquote><p>处理代理实例上的方法调用，并返回结果。当代理对象发生方法调用时，这个方法会被与代理对象关联的 invocation handler 调用。</p><p>proxy – 发生方法调用的实例</p><p>method – 发生调用的方法</p><p>args – 方法调用的参数</p><p><strong>JDK 实现还有一个关键的类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.reflect.Proxy</span><br></pre></td></tr></table></figure><blockquote><p>Proxy provides static methods for creating dynamic proxy classes and instances, and it is also the superclass of all dynamic proxy classes created by those methods.</p></blockquote><p>提供创建代理类和实例的静态方法，是所有被创建代理类的父类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass(ClassLoader loader,</span><br><span class="line">                                         Class&lt;?&gt;... interfaces)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          InvocationHandler h)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InvocationHandler <span class="title">getInvocationHandler</span><span class="params">(Object proxy)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException</span></span><br></pre></td></tr></table></figure><p>上面这三个方法分别获取代理类、代理实例、和关联的 Invocation Handler</p><p>一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserControllerDynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserControllerDynamicProxy</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do something before method invoke"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do something after method invoke"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建要被代理的对象</span></span><br><span class="line">        UserController userController = <span class="keyword">new</span> UserController();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 invocationHandler</span></span><br><span class="line">        UserControllerDynamicProxy userControllerDynamicProxy = <span class="keyword">new</span> UserControllerDynamicProxy(userController);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建代理对象，代理对象是 IUserController 类型，但不是 UserController 类型（面向接口）</span></span><br><span class="line">        IUserController controller = (IUserController)Proxy.newProxyInstance(userController.getClass().getClassLoader(),</span><br><span class="line">                userController.getClass().getInterfaces(), userControllerDynamicProxy);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用代理对象上的方法，引发 invoke 调用</span></span><br><span class="line">        controller.login();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用结果：</span></span><br><span class="line"><span class="keyword">do</span> something before method invoke</span><br><span class="line">login</span><br><span class="line"><span class="keyword">do</span> something after method invoke</span><br></pre></td></tr></table></figure><p>把上面生成的代理类的字节码反编译一下，看一下代理类的结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> DynamicProxy.IUserController;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理类继承了 Proxy，实现了 IUserController 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">UserControllerProxy</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">IUserController</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 被代理对象的所有方法取出来</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m4;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserControllerProxy</span><span class="params">(InvocationHandler var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 invocationHandler 的 invoke() 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m4, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m4 = Class.forName(<span class="string">"DynamicProxy.IUserController"</span>).getMethod(<span class="string">"login"</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">            m3 = Class.forName(<span class="string">"DynamicProxy.IUserController"</span>).getMethod(<span class="string">"register"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来就和静态代理区别不大，就是自动生成了代理类。也可以看出 JDK 动态代理是<strong>面向接口</strong>的，这个代理对象与被代理对象实现了相同的接口。如果被代理对象没有实现接口，那么就不能用 JDK 的动态代理来实现。</p><h3 id="CGLIB-动态代理"><a href="#CGLIB-动态代理" class="headerlink" title="CGLIB 动态代理"></a>CGLIB 动态代理</h3><p>如果被代理对象没有实现接口，那么可以考虑使用 cglib，cglib 采用<strong>创建目标类子类</strong>的方式来实现动态代理。</p><h3 id="JDK-动态代理与-cglib-的比较"><a href="#JDK-动态代理与-cglib-的比较" class="headerlink" title="JDK 动态代理与 cglib 的比较"></a>JDK 动态代理与 cglib 的比较</h3><p>实现上：</p><ul><li>JDK 动态代理使用反射方式实现，必须要有接口的业务类才能使用。</li><li>cglib 基于 ASM（动态字节码操作框架）实现，通过生成业务类的子类来实现。</li></ul><p>优缺点：</p><ul><li>JDK 达到最小依赖，可能比 cglib 稳定。平滑的版本升级。代码实现简单。</li><li>cglib 无需实现接口，达到无侵入。性能较高。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;代理模式&quot;&gt;&lt;a href=&quot;#代理模式&quot; class=&quot;headerlink&quot; title=&quot;代理模式&quot;&gt;&lt;/a&gt;代理模式&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;代理模式（Proxy Design Pattern）：&lt;/strong&gt;在不改变原始类的情况下，通过代理类来
      
    
    </summary>
    
      <category term="Java" scheme="https://firecarrrr.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring Bean 生命周期</title>
    <link href="https://firecarrrr.github.io/2020/05/04/SpringBean/"/>
    <id>https://firecarrrr.github.io/2020/05/04/SpringBean/</id>
    <published>2020-05-04T06:26:59.000Z</published>
    <updated>2020-05-06T13:04:25.687Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a>Spring Bean</h1><p>Spring Bean 是指可以被实例化、组装，并通过 Spring IoC 容器管理的对象。</p><h2 id="BeanFactory-和-ApplicationContext"><a href="#BeanFactory-和-ApplicationContext" class="headerlink" title="BeanFactory 和 ApplicationContext"></a>BeanFactory 和 ApplicationContext</h2><ul><li><strong>BeanFactory:</strong> 基础类型的 IoC 容器，提供完整的 IoC 服务支持。</li><li><strong>ApplicationContext:</strong> ApplicationContext 在 BeanFactory 的基础上构建，是相对比较高级的容器实现，除了拥有 BeanFactory 的所有支持，ApplicationContext 还提供了其它高级特性，比如事件发布、国际化等。</li></ul><h2 id="Spring-Bean-生命周期"><a href="#Spring-Bean-生命周期" class="headerlink" title="Spring Bean 生命周期"></a>Spring Bean 生命周期</h2><h3 id="配置-Spring-Bean-元信息"><a href="#配置-Spring-Bean-元信息" class="headerlink" title="配置 Spring Bean 元信息"></a>配置 Spring Bean 元信息</h3><p>Spring Bean 元信息是指那些描述 Bean 的基本信息。 BeanDefinition 是 Spring 中定义 Bean 配置元信息的接口。BeanDefinition 元信息包括：</p><ul><li><p>Name：Bean的名称或者 ID</p></li><li><p>Class：Bean 的全类名</p></li><li><p>Scope：作用域</p></li><li><p>Constructor arguments：构造器参数</p></li><li><p>Properties：属性</p></li><li><p>Autowiring mode：自动装配模式</p></li><li><p>lazy-initialization mode：延迟初始化模式（延迟和非延迟）</p></li><li><p>Initialization method：初始化回调方法名称</p></li><li><p>Destruction method：销毁回调方法名称</p></li></ul><p>定义 Spring Bean 元信息的方式有三大类：</p><ul><li>面向资源：XML, Properties, Guava</li><li>面向注解</li><li>面向 API</li></ul><p>对于面向资源和面向注解的方式，Spring 利用相应的解析器将其解析为 BeanDefinition。</p><h3 id="注册-Spring-Bean"><a href="#注册-Spring-Bean" class="headerlink" title="注册 Spring Bean"></a>注册 Spring Bean</h3><p>配置好的 BeanDefinition 需要注册到 IoC 容器中。</p><p>BeanDefinitionRegistry 是定义 Bean 注册行为的接口，DefaultListableBeanFactory 是它的一个实现。注册 BeanDefinition 时，是将 BeanName 和 BeanDefinition 保存到一个 ConcurrentHashMap 中，BeanName 以注册顺序被保存到一个 List 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Map of bean definition objects, keyed by bean name. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"><span class="comment">/** List of bean definition names, in registration order. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;String&gt; beanDefinitionNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">256</span>);</span><br></pre></td></tr></table></figure><h3 id="加载-Spring-Bean-Class"><a href="#加载-Spring-Bean-Class" class="headerlink" title="加载 Spring Bean Class"></a>加载 Spring Bean Class</h3><p>AbstractBeanDefinition 中有一个属性时 beanClass，当 Definition 对应的 Class 还没有被加载时，beanClass 是一个 String 记录 Bean Class 的全类名，当 Bean Class 被 ClassLoader 被加载后就是 Bean Class 的 Class 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Object beanClass;</span><br></pre></td></tr></table></figure><h3 id="Spring-Bean-的实例化"><a href="#Spring-Bean-的实例化" class="headerlink" title="Spring Bean 的实例化"></a>Spring Bean 的实例化</h3><p><strong>BeanPostProcessor：</strong>BeanPostProcessor 是一个回调接口，有两个方法，允许在初始化前和后对 Bean 进行修改。BeanPostProcessor 有一些子接口，添加了在生命周期其它阶段对 Bean 的拦截操作，比如 InstantiationAwareBeanPostProcessor , DestructionAwareBeanPostProcessor 等。BeanPostProcessor 和 BeanFactory 之间是 N : 1 的关系。BeanPostProcessor 通过配置 Bean 的方式注册到 Spring 容器中。</p><p><strong>实例化前操作：</strong>InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation 方法可以在实例化之前生成一个代理对象，之后就不会执行 BeanDefinition 中定义的实例化操作。下面这个例子中，拦截了 User 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ObjectUtils.nullSafeEquals(<span class="string">"user"</span>, beanName) &amp;&amp; User.class.equals(beanClass)) &#123;</span><br><span class="line">        <span class="comment">// 把配置完成的 User 替换掉</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保持 Spring IoC 容器的实例化操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实例化：</strong>这里就是执行 Bean 构造器的，可能是执行无参构造器，也可能是执行有参构造器。</p><p><strong>实例化后操作：</strong>InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation 方法可以在 Spring Bean 实例化后，属性被填充前被调用。如果方法返回 false，该 Bean 实例将不允许属性赋值，也就不会执行配置元信息中定义的赋值操作。如果返回 true，就会保持 Spring IoC 容器的赋值操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ObjectUtils.nullSafeEquals(<span class="string">"user"</span>, beanName) &amp;&amp; User.class.equals(bean.getClass())) &#123;</span><br><span class="line">        User user = (User) bean;</span><br><span class="line">        user.setId(<span class="number">2L</span>);</span><br><span class="line">        user.setName(<span class="string">"hello"</span>);</span><br><span class="line">        <span class="comment">// user 对象不允许属性赋值填入 就是不填入配置元信息中的值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保持 Spring IoC 容器的属性赋值操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring-Bean-属性赋值"><a href="#Spring-Bean-属性赋值" class="headerlink" title="Spring Bean 属性赋值"></a>Spring Bean 属性赋值</h3><p><strong>赋值前阶段：</strong>InstantiationAwareBeanPostProcessor#postProcessProperties 是 Spring Bean 赋值前的回调，可以修改赋值参数-值元数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ObjectUtils.nullSafeEquals(<span class="string">"user"</span>, beanName) &amp;&amp; User.class.equals(bean.getClass())) &#123;</span><br><span class="line">        MutablePropertyValues propertyValues;</span><br><span class="line">        <span class="keyword">if</span>(pvs <span class="keyword">instanceof</span> MutablePropertyValues)&#123;</span><br><span class="line">            propertyValues = (MutablePropertyValues) pvs;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            propertyValues = <span class="keyword">new</span> MutablePropertyValues();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(propertyValues.contains(<span class="string">"city"</span>))&#123;</span><br><span class="line">            propertyValues.removePropertyValue(<span class="string">"city"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        propertyValues.addPropertyValue(<span class="string">"city"</span>, <span class="string">"chengdu"</span>);</span><br><span class="line">        <span class="keyword">return</span> propertyValues;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Bean 属性赋值：</strong></p><p><strong>Spring Aware 接口回调：</strong>Aware 接口是一个标记接口，用于 Spring 容器回调以注入相应的组件。Aware 的子接口包括，对 Aware 接口的回调发生在 Bean 属性赋值之后：</p><ul><li>BeanNameAware</li><li>BeanClassLoaderAware</li><li>BeanFactoryAware</li><li>EnvironmentAware</li><li>EmbeddedValueResolverAware</li><li>ResourceLoaderAware</li><li>ApplicationEventPublisherAware</li><li>MessageSourceAware</li><li>ApplicationContextAware</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserHolder</span> <span class="keyword">implements</span> <span class="title">BeanNameAware</span>, <span class="title">BeanClassLoaderAware</span>, <span class="title">BeanFactoryAware</span>, <span class="title">EnvironmentAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ClassLoader classLoader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String beanName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserHolder</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanClassLoader</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.classLoader = classLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanName = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.environment = environment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring-Bean-初始化"><a href="#Spring-Bean-初始化" class="headerlink" title="Spring Bean 初始化"></a>Spring Bean 初始化</h3><p><strong>初始化前：</strong>BeanPostProcessor#postProcessBeforeInitialization 可以在 Bean 初始化前做一些操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ObjectUtils.nullSafeEquals(<span class="string">"user"</span>, beanName) &amp;&amp; User.class.equals(bean.getClass())) &#123;</span><br><span class="line">        User user = (User) bean;</span><br><span class="line">        user.setName(<span class="string">"FireCar"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>初始化：</strong></p><ul><li>@PostConstruct 注解</li><li>实现 InitializingBean 接口的 afterPropertiesSet() 方法</li><li>自定义初始化方法 (init-method)</li></ul><p>在 Spring 容器中执行的顺序也是上面这个顺序。</p><p><strong>初始化后回调：</strong>BeanPostProcessor#postProcessAfterInitialization 在 Bean 初始化后做一些操作。</p><p><strong>初始化完成阶段：</strong>实现 SmartInitializingSingleton#afterSingletonsInstantiated 方法</p><h3 id="Spring-Bean-销毁"><a href="#Spring-Bean-销毁" class="headerlink" title="Spring Bean 销毁"></a>Spring Bean 销毁</h3><p><strong>销毁前回调：</strong>DestructionAwareBeanPostProcessor#postProcessBeforeDestruction</p><p><strong>销毁：</strong></p><ul><li>@PreDestory</li><li>实现 DisposableBean 的 destroy() 方法</li><li>自定义实现 (destroy-method)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring-Bean&quot;&gt;&lt;a href=&quot;#Spring-Bean&quot; class=&quot;headerlink&quot; title=&quot;Spring Bean&quot;&gt;&lt;/a&gt;Spring Bean&lt;/h1&gt;&lt;p&gt;Spring Bean 是指可以被实例化、组装，并通过 Spring
      
    
    </summary>
    
      <category term="Java" scheme="https://firecarrrr.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>HTTPS与TLS</title>
    <link href="https://firecarrrr.github.io/2020/04/22/TLS/"/>
    <id>https://firecarrrr.github.io/2020/04/22/TLS/</id>
    <published>2020-04-22T13:01:08.000Z</published>
    <updated>2020-04-22T15:18:21.653Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>HTTP 是基于明文传输的，不具有安全性。很容易被攻击者截获、更改。HTTPS 协议是基于 SSL/TLS 协议上的安全的传输协议。</p><h2 id="如何定义安全？"><a href="#如何定义安全？" class="headerlink" title="如何定义安全？"></a>如何定义安全？</h2><ul><li><strong>机密性</strong>：数据是被加密的</li><li><strong>完整性</strong>：数据是不可篡改的</li><li><strong>身份认证</strong>：能够确定通信方的身份</li></ul><h3 id="机密性的实现"><a href="#机密性的实现" class="headerlink" title="机密性的实现"></a>机密性的实现</h3><h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><p>加密和解密使用同一个密钥</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="对称加密.png" alt="对称加密.png" title>                </div>                <div class="image-caption">对称加密.png</div>            </figure><p>对称加密的问题在于无法解决<strong>密钥交换</strong>的问题，就是说怎么安全的将密钥传递给对方？</p><p>常见的对称加密算法：AES,  ChaCha20等</p><h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a><strong>非对称加密</strong></h4><p>存在<strong>公钥（公开）</strong>和<strong>私钥（严格保密）</strong>两个密钥</p><p>加密解密过程具有单向性：公钥加密只能用私钥解密，反之亦然</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="非对称加密.png" alt="非对称加密.png" title>                </div>                <div class="image-caption">非对称加密.png</div>            </figure><p>常用的非对称加密算法：RSA, ECC等</p><h4 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h4><p>对称加密无法解决密钥交换问题，非对称加密很慢</p><p>融合两种加密方式优点的解决方案是混合加密</p><ol><li>通信开始时，先用非对称加密解决密钥交换问题</li><li>拿到密钥后，双方使用对称加密进行通信</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="混合加密.png" alt="混合加密.png" title>                </div>                <div class="image-caption">混合加密.png</div>            </figure><h3 id="完整性的实现"><a href="#完整性的实现" class="headerlink" title="完整性的实现"></a>完整性的实现</h3><h4 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h4><p>就是用一个 hash 函数，把数据压缩成一个固定长度、独一无二的摘要字符串</p><p>常用的摘要算法：MD5、SHA-1、SHA-2（TLS 推荐使用）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="摘要算法.png" alt="摘要算法.png" title>                </div>                <div class="image-caption">摘要算法.png</div>            </figure><p>通信一方在发送消息时，也发送消息摘要；通信另一方解密后，再算一次摘要，进行比对。一样就是完整、未经篡改的数据。</p><h3 id="身份认证的实现"><a href="#身份认证的实现" class="headerlink" title="身份认证的实现"></a>身份认证的实现</h3><h4 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h4><p>利用<strong>私钥</strong>加密<strong>摘要</strong>就能实现数字签名</p><p>因为被私钥加密的摘要只能被对应的公钥解密，这就验证了消息发送者的身份</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="数字签名.png" alt="数字签名.png" title>                </div>                <div class="image-caption">数字签名.png</div>            </figure><h4 id="数字证书和-CA"><a href="#数字证书和-CA" class="headerlink" title="数字证书和 CA"></a>数字证书和 CA</h4><p>如何判断公钥的来源？如何防止黑客伪造公钥？</p><p>CA(Certificate Authority): 证书认证机构，作为一个第三方，用自己的私钥来给公钥签名。把公钥和相关信息一起加密达成一个包，形成了<strong>数字证书</strong>。</p><p>客户端的”证书管理器“中有”受信任的根证书颁发机构“列表。客户端会根据这张表，查看解开数字证书的公钥是否在列表之中。如果在就用它解开数字证书，如果数字证书中记录的网址与正在浏览的网址不一致，就说明证书可能被冒用，浏览器会发出警告。</p><h1 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h1><p>SSL 即安全套阶层（Secure Socket Layer）,在 OSI 模型中处于第五层（会话层）。SSL 发展到 v3 时已经被证明了是一个非常好的安全通信协议，于是 IETF 把它改名为 TLS（Transport Layer Security），正式标准化，版本号从 1.0 开始算起，实际上 TLS1.0 就是 SSLv3.1。</p><h2 id="抓包-TLS-1-2-连接过程"><a href="#抓包-TLS-1-2-连接过程" class="headerlink" title="抓包 TLS 1.2 连接过程"></a>抓包 TLS 1.2 连接过程</h2><p>下面抓包百度，看看连接建立过程。开始用 Chrome 访问，Chrome 似乎做了一些神奇的优化？一些包抓不到。用 FireFox 就好了。</p><ol><li>TCP 连接建立后，浏览器首先会发送一个 Client Hello 消息。消息包括版本号、支持的密码套件、还有一个随机数。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="ClientHello.jpg" alt="ClientHello.jpg" title>                </div>                <div class="image-caption">ClientHello.jpg</div>            </figure><ol start="2"><li>服务器收到 Client Hello 后，返回一个 Server Hello。会返回版本号、从密码套件中选择一个、一个随机数。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="ServerHello.jpg" alt="ServerHello.jpg" title>                </div>                <div class="image-caption">ServerHello.jpg</div>            </figure><p>可以看出百度选择了用 ECDHE 做密钥交换算法。ECDHE 是 ECC 的一个子算法，基于椭圆曲线离散对数。</p><ol start="3"><li>服务器把证书发送给客户端。客户端可以解析证书，取出服务器的公钥。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="certificate.jpg" alt="certificate.jpg" title>                </div>                <div class="image-caption">certificate.jpg</div>            </figure><ol start="4"><li>服务端发送 Server Key Exchange 消息，发送椭圆曲线的公钥（Server Params），再加上自己的私钥签名。客户端可以验证这个消息来自于服务器。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="SKexchange.jpg" alt="SKexchange.jpg" title>                </div>                <div class="image-caption">SKexchange.jpg</div>            </figure><ol start="5"><li>发送 Server Hello Done 消息。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="ServerHelloDone.png" alt="ServerHelloDone.png" title>                </div>                <div class="image-caption">ServerHelloDone.png</div>            </figure><ol start="6"><li>客户端生成一个椭圆曲线公钥（Client Params），用 Client Key Exchange 消息发送给服务器。 </li></ol><p><img src="CKE.png" alt="CKE.png"></p><ol start="7"><li><p>客户端和服务器都拿到了 Client Params、Server Params，用 ECDHE 算法，算出 Pre-Master。黑客即便拿到了前面两个参数也算不出 Pre-Master（why？）。客户端和服务器用 Client Random、Server Random、Pre-Master 生成用于加密会话的主密钥 Master Secret，由于 Pre-Master 是保密的，Master Secret 也是保密的。</p></li><li><p>客户端发送 Change Cipher Spec。再发送一个 Finished 消息，把之前所有发送的数据做个摘要，再加密发送给对方做个验证。服务器同样发送 Change Cipher Spec 和 finish。双方都验证加密、解密 OK，握手结束。后面就收发被加密的 HTTP 请求和响应。</p><p><img src="finish.png" alt="finish.png"></p><p><strong>整体流程：</strong></p><p><img src="%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B.png" alt="整体流程.png"></p><p>上面这个过程其实是<strong>单向认证</strong>的握手过程，只认证了服务器的身份（通过服务器证书），而没有认证客户端的身份。因为单向认证过后已经建立了安全通信，可以通过账号、密码来确认用户身份。</p><p>银行的 U 盾就是给用户颁发客户端证书，实现双向认证。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HTTPS&quot;&gt;&lt;a href=&quot;#HTTPS&quot; class=&quot;headerlink&quot; title=&quot;HTTPS&quot;&gt;&lt;/a&gt;HTTPS&lt;/h1&gt;&lt;p&gt;HTTP 是基于明文传输的，不具有安全性。很容易被攻击者截获、更改。HTTPS 协议是基于 SSL/TLS 协议上的
      
    
    </summary>
    
    
      <category term="HTTPS" scheme="https://firecarrrr.github.io/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>Reactor</title>
    <link href="https://firecarrrr.github.io/2020/04/15/Reactor/"/>
    <id>https://firecarrrr.github.io/2020/04/15/Reactor/</id>
    <published>2020-04-15T10:51:16.000Z</published>
    <updated>2020-04-15T14:21:53.481Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Reactor-模式"><a href="#Reactor-模式" class="headerlink" title="Reactor 模式"></a>Reactor 模式</h1><p> NIO 这部分一直迷迷糊糊的，想借学 Reactor 这部分的时候来谈一下。</p><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><p>所谓I/O就是内存和外部设备之间拷贝数据的过程。以网络 I/O为例，也就是用户程序从网卡读取数据和向网卡写数据的过程。这个过程可以被分为两个步骤：</p><ul><li>内核从网卡把数据拷贝到内核缓存</li><li>数据从内核读取到用户程序地址空间</li></ul><p>各种 I/O 模型的区别在于：实现这两个步骤的方式不一样</p><h2 id="同步阻塞-I-O-与-TPC"><a href="#同步阻塞-I-O-与-TPC" class="headerlink" title="同步阻塞 I/O 与 TPC"></a>同步阻塞 I/O 与 TPC</h2><p>TPC 也就是 Thread Per Connection，就是说服务器在处理客户端请求的时候，为每一个客户端分配一个线程去处理。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="tpc.png" alt="tpc.png" title>                </div>                <div class="image-caption">tpc.png</div>            </figure><p>这里之所以需要为每一个请求分配单独的线程是因为 read、write 这些调用都是同步阻塞的。如果单线程，一阻塞，系统就没办法响应新的请求了。</p><p>TPC 的问题在于，创建线程和线程的上下文切换都是需要代价的。面对海量连接，这种模型是无能为力的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionHandler</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Socket socket;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ConnectionHandler</span><span class="params">(Socket socket)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted() &amp;&amp; !socket.isClosed())&#123;</span><br><span class="line">                <span class="comment">// 处理读写事件</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 线程池</span></span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket();</span><br><span class="line">            serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line">            <span class="comment">// 主线程循环等待新连接到来</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                Socket socket = serverSocket.accept();</span><br><span class="line">                <span class="comment">// 把任务提交给线程池</span></span><br><span class="line">                executor.submit(<span class="keyword">new</span> ConnectionHandler(socket));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Reactor-模式-1"><a href="#Reactor-模式-1" class="headerlink" title="Reactor 模式"></a>Reactor 模式</h2><p>TPC 之所以需要创建那么多线程，是因为在执行那些 I/O 操作的时候，并不知道内核是否已经把数据准备好，只能傻等。</p><p>NIO 能够解决这个问题，只需要在 Selector 上注册我们感兴趣的事件（有新连接到来、读就绪、写就绪等）。NIO 能同时监听多个连接，当某条连接上就绪时，操作系统就会通知线程，从阻塞态返回，开始处理。</p><p>Reactor 模式就是利用 NIO 的这种 I/O 多路复用的特性来实现的更高性能的单机高并发模型。Reactor 模式又叫做 Dispatcher 模式，即 I/O 多路复用统一监听事件，收到事件后 Dispatch 给某个线程。</p><p>Reactor 的核心组件包括 Reactor 和处理资源池，典型的配置方案包括：</p><ul><li>单 Reactor / 单线程</li><li>单 Reactor / 多线程</li><li>多 Reactor / 多线程</li></ul><h3 id="单-Reactor-单线程"><a href="#单-Reactor-单线程" class="headerlink" title="单 Reactor / 单线程"></a>单 Reactor / 单线程</h3><p>Redis 就是典型的单 Reactor / 单线程模型</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="oneReactorOneThread.png" alt="单Reactor/单线程.png" title>                </div>                <div class="image-caption">单Reactor/单线程.png</div>            </figure><p>客户端发来请求，Reactor 对象通过 Select 监听到连接事件。收到事件后，如果是建立连接的事件，则交给 Acceptor 处理，Acceptor 通过 accept 接受连接，并创建一个 Handler 处理后续时间。如果不是连接建立时间则调用 Acceptor 中建立的 Handler 来进行响应。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneThreadReactor</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储连接和 Handler 之间的关系</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;SocketChannel, ChannelHandler&gt; handlerHashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>(Selector selector = Selector.open();</span><br><span class="line">            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open())&#123;</span><br><span class="line">            serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line">            <span class="comment">// 设置 channel 为非阻塞</span></span><br><span class="line">            serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 注册到 selector, 设置关注状态</span></span><br><span class="line">            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 阻塞等待就绪的 channel</span></span><br><span class="line">                selector.select();</span><br><span class="line">                <span class="comment">// 获取所有就绪的 channel</span></span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    SelectionKey key = iterator.next();</span><br><span class="line">                    <span class="comment">// 接受连接并注册 handler</span></span><br><span class="line">                    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">                        registerHandler((ServerSocketChannel) key.channel(), selector);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 调用连接对应 Handler 处理读事件</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable()) &#123;</span><br><span class="line">                        getHandler((SocketChannel) key.channel()).channelReadable();</span><br><span class="line">                    &#125;</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接受连接并绑定处理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serverSocketChannel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerHandler</span><span class="params">(ServerSocketChannel serverSocketChannel, Selector selector)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">            socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">            handlerHashMap.put(socketChannel, <span class="keyword">new</span> ChannelHandler(socketChannel));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取绑定的 handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> socketChannel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ChannelHandler <span class="title">getHandler</span><span class="params">(SocketChannel socketChannel)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handlerHashMap.get(socketChannel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OneThreadReactor server = <span class="keyword">new</span> OneThreadReactor();</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单 Reactor / 单线程模型没有线程的切换，确实效率非常高，但是也有它的局限性。第一是不能利用多核能力。第二是应用场景有限，只适合处理速度非常快的场景，如果处理逻辑里有访问数据库等耗时操作，整个服务器就卡住了。</p><h3 id="单-Reactor-多线程"><a href="#单-Reactor-多线程" class="headerlink" title="单 Reactor / 多线程"></a>单 Reactor / 多线程</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="oneReactorMuiltyThread.png" alt="单Reactor/多线程.png" title>                </div>                <div class="image-caption">单Reactor/多线程.png</div>            </figure><p>和单 Reactor / 单线程的区别是，Handler 不会负责业务处理，Handler 通过 read 读取到数据后，会发送给 Processor 进行业务处理。业务处理完成之后，会将结果发给主线程中的 send 将相应结果返回给 client。</p><h3 id="多-Reactor-多线程"><a href="#多-Reactor-多线程" class="headerlink" title="多 Reactor / 多线程"></a>多 Reactor / 多线程</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="muiltyRactor.png" alt="多Reactor/多线程.png" title>                </div>                <div class="image-caption">多Reactor/多线程.png</div>            </figure><p>父线程只监听连接的建立事件，当出现连接建立事件后 Acceptor 接受连接，并将新连接分配给某个子线程。子线程将监听连接，并创建一个对应的 Handler。当事件发生后，子线程调用 Handler 来做相应。</p><p>Ngnix（具体实现上有差异）、Netty 就是采用这种模型。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Reactor-模式&quot;&gt;&lt;a href=&quot;#Reactor-模式&quot; class=&quot;headerlink&quot; title=&quot;Reactor 模式&quot;&gt;&lt;/a&gt;Reactor 模式&lt;/h1&gt;&lt;p&gt; NIO 这部分一直迷迷糊糊的，想借学 Reactor 这部分的时候来谈一下
      
    
    </summary>
    
      <category term="Java" scheme="https://firecarrrr.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL事务隔离和MVCC</title>
    <link href="https://firecarrrr.github.io/2019/08/04/mysql-transaction/"/>
    <id>https://firecarrrr.github.io/2019/08/04/mysql-transaction/</id>
    <published>2019-08-04T08:25:20.000Z</published>
    <updated>2019-08-24T14:44:13.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL事务隔离和MVCC"><a href="#MySQL事务隔离和MVCC" class="headerlink" title="MySQL事务隔离和MVCC"></a>MySQL事务隔离和MVCC</h1><p>同样，把最近看的事务和锁的部分总结一下，这部分的确东西蛮多的。</p><h2 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h2><p>其实事务这东西说白了就是一组操作的集合。我们希望数据库系统能够保证这一组操作数据一致且操作独立。数据一致就是说事务在提交的时候保证事务内的所有操作都能成功完成，并且永久生效。操作独立是说多个同时执行的事务之间应该是相互独立，互不影响的。</p><p>用标准一点的说法，还就是老生常谈的ACID，感觉ACID更像是目标吧，真实的系统不一定能实现：</p><ul><li><p><strong>原子性（atomicity）：</strong>这个最好理解，就是说一个事务的所有操作是不可分隔的最小工作单元，要么全部成功，要么全部失败。</p></li><li><p><strong>一致性（consistency）：</strong>数据库总是从一个一致性状态转换到另一个一致性状态。在任何时刻，包括数据库正常提供服务的时候，数据库从异常中恢复过来的时候，数据都是一致的，保证不会读到中间状态的数据。每本数据库书里都会举的转账的例子，A转200块给B的这个转账的事务执行后，A的钱少了200，B的钱就一定会多200。数据库不会因为这个事务的执行，出现逻辑上不一致的状况。</p></li><li><p><strong>隔离性（isolation）：</strong>所有事情当出现在并发的场景下都会变得复杂。通常来说，一个事务所做的修改在最终提交之前，对其他事务是不可见的。在真实地数据库系统中，不尽然是这样的，可以通过设置不同的<strong>隔离级别（isolation level）</strong>来调整不同事务操作对彼此的可见性。</p></li><li><p><strong>持久性（durability）：</strong>一旦事务提交，其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。</p></li></ul><p>并不是所有存储引擎都支持事务，比如MyISAM就不支持事务。</p><h3 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h3><p>当数据库中有多个事务同时执行的时候，如果不加控制，就会出现各种各样的问题：</p><ul><li><p><strong>脏读（dirty read）：</strong>当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中的时候，另一个事务也访问了这个数据<strong>（脏数据）</strong>。</p></li><li><p><strong>不可重复读（non-repeatable read）：</strong>是指在一个事务中，多次读同一个数据。两次读取之间，另一个事务修改了数据，造成第一个事务两次读取数据不一致的情况。</p></li><li><p><strong>幻读（phantom read）：</strong>当保证了可重复读后，事务进行过程中查询的结果都是事务开始时的状态。但是如果另一个事务提交了数据，本事务再更新时，就可能会出现错误，就好像之前读到的数据是“鬼影”一样的幻觉似的。比如，第一个事务对一个表中的数据进行了修改或读取，这种修改或读取涉及到表中所有的数据行。同时，第二个事务向表中插入了一行新数据，就会发生第一个事务发现有行没有被修改的情况。</p></li></ul><p>为了解决这些问题，就有了<strong>隔离级别</strong>的概念，SQL的标准隔离级别有：</p><ul><li><p><strong>读未提交（read uncommitted）：</strong>一个事务还没提交时，它做的变更就能被其它事务看到（这不就相当于没隔离吗），所有的问题都可能发生。</p></li><li><p><strong>读提交（read committed）：</strong>一个事务提交之后，它做的变更才能被其它事务看到。读提交可以解决脏读的问题。</p></li><li><p><strong>可重复读（repeatable read）：</strong>一个事务在执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。可重复读解决了脏读和不可重复读的问题但是没有解决幻读的问题。可重复读是MySQL的<strong>默认事务隔离级别</strong>。</p></li><li><p><strong>串行化（serializable）：</strong>强制让事务串行执行，最高的隔离级别。</p></li></ul><p>随着隔离级别的提升，出现并发问题的可能性在减小，可是并发性能也在降低。很多时候都是个权衡的问题。</p><h2 id="多版本并发控制——MVCC"><a href="#多版本并发控制——MVCC" class="headerlink" title="多版本并发控制——MVCC"></a>多版本并发控制——MVCC</h2><p>MVCC是一种提高并发的技术。在最早的数据库系统中，只有读读之间可以并发，读写，写读，写写都是要阻塞的。引入MVCC之后，只有写写之间是相互阻塞的，其它三种操作都可以并行，大幅提高了InnoDB的并发度。在多事务环境下，对数据读写在不加读写锁的情况下实现互补干扰，<strong>从而实现了数据库的隔离性</strong>。</p><h3 id="MVCC的实现"><a href="#MVCC的实现" class="headerlink" title="MVCC的实现"></a>MVCC的实现</h3><h4 id="Undo-Log"><a href="#Undo-Log" class="headerlink" title="Undo Log"></a>Undo Log</h4><p>undo log主要用于存放数据被修改前的值。undo log分为两类，一种是INSERT_UNDO，记录插入的唯一键值；一种是UPDATE_UNDO，包括UPDATE及DELETE操作，记录修改的唯一键值以及old column记录。undo log主要由两个作用：</p><ul><li>事务回滚</li><li>MVCC多版本控制</li></ul><p>InnoDB以聚簇索引的方式存储数据，MySQL默认为每个索引添加了4个隐藏的字段。</p><p>其中</p><ul><li><strong>DB_ROLL_PTR</strong>：是undo log的指针，用于记录之前的历史数据在undo log中的位置。undo log中的历史数据行中的<code>DB_ROLL_PTR</code>指向的是上一次修改的行的undo log。这样多次更新后，回滚指针会把不同的版本的记录串在一起。</li><li><strong>DB_ROW_ID</strong>：是如果没有定义主键和合适的键做主键的时候，MySQL自己生成的一个隐藏的主键。</li><li><strong>DB_TRX_ID</strong>：是最近更改改行数据的事务ID。</li><li><strong>DELETE_BIT</strong>：是索引删除标志，如果DB删除了一条数据，是优先通知索引将这个标志位设置为1，然后通过清除线程去异步删除真实的数据</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="mvcc3.png" alt="索引隐藏字段.png" title>                </div>                <div class="image-caption">索引隐藏字段.png</div>            </figure><p>整个innoDB的MVCC机制都是通过<code>DB_ROLL_PTR</code>和<code>DB_TRX_ID</code>这两个字段实现的。</p><h4 id="Read-View"><a href="#Read-View" class="headerlink" title="Read View"></a>Read View</h4><p>由于undo log的存在，数据的多个版本得以保存。这就给事务隔离的实现创造了条件，对于RR和RC隔离级别的事务，对数据进行访问之前都需要对数据的可见性进行判断，也就是说需要判断当前事务是否能看到这一行数据，看到的应该是哪个版本的数据。这些功能的实现依赖于Read View对象。</p><p>首先，当一个事务开始的时候，会将当前数据库中正在活跃的所有事务（执行begin，但是还没有commit的事务）保存到一个叫做<code>trx_sys</code>的事务链表中，事务链表中保存的都是未提交的事务，当事务提交之后会从中删除。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="trx_sys.png" alt="活跃事务链表.png" title>                </div>                <div class="image-caption">活跃事务链表.png</div>            </figure><p>Read View的初始化相当于给当前的<code>trx_sys</code> 打一个快照。</p><ul><li>活跃事务链表(<code>trx_sys</code>)中事务id最大的值被赋值给<code>m_low_limit_id</code>。</li><li>活跃事务链表中第一个值(也就是事务id最小)被赋值给<code>m_up_limit_id</code>。</li><li><code>m_ids</code> 为事务链表。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// readview 初始化</span></span><br><span class="line"><span class="comment">// m_low_limit_id = trx_sys-&gt;max_trx_id; </span></span><br><span class="line"><span class="comment">// m_up_limit_id = !m_ids.empty() ? m_ids.front() : m_low_limit_id;</span></span><br><span class="line">ReadView::ReadView()</span><br><span class="line">    :</span><br><span class="line">    m_low_limit_id(),</span><br><span class="line">    m_up_limit_id(),</span><br><span class="line">    m_creator_trx_id(),</span><br><span class="line">    m_ids(),</span><br><span class="line">    m_low_limit_no()</span><br><span class="line">&#123;</span><br><span class="line">    ut_d(::<span class="built_in">memset</span>(&amp;m_view_list, <span class="number">0x0</span>, <span class="keyword">sizeof</span>(m_view_list)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个Read View，事务就可以根据查询到的所有记录的<code>DB_TRX_ID</code>来匹配是否能看见该记录。</p><ul><li>当检索到的数据的事务ID(数据事务ID &lt; <code>m_up_limit_id</code>) 小于事务链表中的最小值表示这个数据在当前事务开启前就已经被其他事务修改过了,所以是可见的。</li><li>当检索到的数据的事务ID(数据事务ID = <code>m_creator_trx_id</code>) 表示是当前事务自己修改的数据。</li><li>当检索到的数据的事务ID(数据事务ID &gt;= <code>m_low_limit_id</code>) 大于事务链表中的最大值表示这个数据在当前事务开启之前又被其他的事务修改过,那么就是不可见的。</li><li>如果事务ID落在(<code>m_up_limit_id</code>,<code>m_low_limit_id</code>)，需要在活跃读写事务数组查找事务ID是否存在，如果存在，记录对于当前read view是不可见的。</li></ul><p><strong>如果记录对于view不可见，需要通过记录的<code>DB_ROLL_PTR</code>指针遍历history list构造当前view可见版本数据</strong>。</p><p>上面基本上是对于聚簇索引的情况，对于二级索引，在二级索引页中存储了更新当前页的最大事务ID，<strong>如果该事务ID大于read view中的<code>m_up_limit_id</code>，那么就需要回聚簇索引判断记录可见性。</strong></p><p>RR隔离级别（除了Gap锁之外）和RC隔离级别的差别是创建read view的时机不同。<strong>RR隔离级别是在事务开始时刻，确切地说是第一个读操作创建read view的；RC隔离级别是在语句开始时刻创建read view的。</strong></p><p><strong>undo log什么时候会被删除呢？</strong></p><p>当该undo log关联的事务没有出现在其他事务的read view中时(事务已提交，且没有其他事务依赖当前事务)，那么InnoDB引擎的后台清除线程(purge线程)会进行遍历删除undo log操作。</p><p>因此长事务会导致数据库中存在大量的undo log，占用大量的存储空间。所以<strong>应该尽量避免长事务</strong>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一个月一篇的速度真的是醉了。。。未完待续</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL事务隔离和MVCC&quot;&gt;&lt;a href=&quot;#MySQL事务隔离和MVCC&quot; class=&quot;headerlink&quot; title=&quot;MySQL事务隔离和MVCC&quot;&gt;&lt;/a&gt;MySQL事务隔离和MVCC&lt;/h1&gt;&lt;p&gt;同样，把最近看的事务和锁的部分总结一下，这部
      
    
    </summary>
    
      <category term="MySQL" scheme="https://firecarrrr.github.io/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL索引（一）</title>
    <link href="https://firecarrrr.github.io/2019/07/20/mysql-index/"/>
    <id>https://firecarrrr.github.io/2019/07/20/mysql-index/</id>
    <published>2019-07-20T09:11:18.000Z</published>
    <updated>2019-07-20T09:20:21.078Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h1><p>最近在看数据库索引相关的内容，想写成blog，一来整理一下笔记，二来整理一下思路。</p><p>索引的目的是加快数据访问的速度，要实现这个目的需要用到一些高效的数据结构。索引是在存储引擎层实现的，不同的存储引擎可能采用不同的实现方式，用到的数据结构也不尽相同。</p><h2 id="索引的数据结构基础"><a href="#索引的数据结构基础" class="headerlink" title="索引的数据结构基础"></a>索引的数据结构基础</h2><h3 id="B-Tree和B-Tree"><a href="#B-Tree和B-Tree" class="headerlink" title="B-Tree和B+ Tree"></a>B-Tree和B+ Tree</h3><p>MySQL的默认存储引擎InnoDB使用B+ Tree来实现索引，B+ Tree是B-Tree的一个变种，基本上大部分存储引擎都是使用B-Tree类的数据结构来实现索引的。</p><p><strong>为什么要用B-Tree或者B-Tree产生的动机是什么？</strong></p><p>B-Tree本质上是二叉搜索树的一个推广，每一个B-Tree内部节点x有x.n个关键字，这x.n个关键字从小到大依次排列，把关键字分成了x.n+1个区间，那么x就有x.n+1个孩子节点分别存储这些区间范围内的关键字。由于n的数值可以很大，所以B-Tree的树高可以很低，树高低就意味着找到目标需要的随机IO次数少。n的值取多少合适呢？</p><p>我们存储在数据库里的数据，是存储在磁盘上的（也有可能是SSD啦，不过很贵吧），磁盘作为一种依靠磁臂在不同磁道和扇区之间机械运动读取数据的存储装置，与内存和CPU相比就很慢。要加快数据的访问速度那就要减少磁盘IO的次数。磁盘本身存储数据的最小单位是扇区（一般为512 byte），而操作系统的文件系统不是以扇区为单位来读取磁盘的，因为这太慢了，所以有了block（块）的概念，它是一个块一个块的读取的，如果要读取的数据超过一块就会触发多次IO，一个块的大小一般是4K byte。</p><p>一个B-Tree算法的运行时间主要由它执行磁盘读写的时间决定，所以，一个B-Tree节点的大小通常和一个完整的块的大小一样大。因此，磁盘块的大小限制了B-Tree节点可以含有的孩子个数。</p><p>B+ Tree是B-Tree的一个常见变种，B+Tree把所有的卫星数据（除作为键值外的其他数据）都存储在叶子节点里，也就是说非叶节点只存储键值和孩子指针，并且叶子节点之间用指针连接。</p><p><strong>B-Tree由于它的有序性，所以增删节点，维护起来会耗费额外的资源</strong></p><p><strong>所以索引会提高查询效率，但是会降低写入和删除的效率</strong></p><h3 id="Hash表"><a href="#Hash表" class="headerlink" title="Hash表"></a>Hash表</h3><p>hash表没啥可说的，key-value存储方式。需要注意的是，由于hash索引不会按键值顺序存储，所以<strong>hash索引只适用于等值查询的场景，做区间查询会很慢，也没法做部分匹配。</strong></p><h2 id="索引的细节"><a href="#索引的细节" class="headerlink" title="索引的细节"></a>索引的细节</h2><p>下面关于索引的讨论基本上都是针对于MySQL默认存储引擎InnoDB而言的。</p><h3 id="聚簇索引与二级索引"><a href="#聚簇索引与二级索引" class="headerlink" title="聚簇索引与二级索引"></a>聚簇索引与二级索引</h3><p>对于InnoDB而言，聚簇索引其实就是主键索引，在索引的叶子节点中，存储了包含全部数据的数据行。<strong>“聚簇”的意思是说数据行和相邻键值的数据行紧凑的存储在一起（并非一直成立）。</strong></p><p>聚簇索引的实现同样依赖于存储引擎，并非所有存储引擎都支持聚簇索引。聚簇索引的优点显而易见，聚簇索引可以最大限度的提高IO密集型应用的性能。但是这种使用这种精巧的数据结构存储数据都会面临维护上的开销。对于聚簇索引来说：</p><ul><li><p><strong>插入新数据行的速度严重依赖于插入顺序。</strong>按照主键顺序插入到InnoDB表中速度肯定是最快的，非顺序插入不仅慢而且会导致很多磁盘碎片的产生。所以一般尽量用自增主键做主键值，这样在性能上和存储空间上都有优势。</p></li><li><p><strong>更新主键的代价很大。</strong>因为是数据行按主键顺序紧密存储的，所以更新主键就会带来数据行的移动。</p></li><li><p><strong>插入新行（乱序）、主键更新需要移动行时，都可能面临“页分裂（page split）”问题。</strong>当需要把一行插入到一个已满页面的时候，存储引擎会把这个页分裂成两个页来容纳这个行，页分裂操作会导致占用更多磁盘空间，空间利用率降低。</p></li><li><p><strong>聚簇索引会让全表扫描变慢，尤其是行比较稀疏的时候，或者由于页分裂导致数据存储不连续的时候。</strong>这应该是和把所有数据行直接连续存储相比而言的。</p></li></ul><p>二级索引就是指非主键索引，二级索引的叶子节点中除了存储索引列的值之外，还存储了对应行的主键值。这是与MyISAM存储引擎的一个明显的不同，MyISAM索引的叶子节点中存储的时指向数据行的行指针（MyISAM存储引擎按照数据的插入顺序，将数据行存储在磁盘上）。</p><p>InnoDB这种存储主键的方式带来了一个显而易见的好处就是<strong>减少了出现行移动或者数据页分裂时二级索引的维护工作。</strong>也带来了一个显而易见的坏处就是<strong>使用二级索引查询索引不能覆盖的列信息时，需要再到主键索引表回表查询一次。</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="索引对比.png" alt="innoDB和MyISAM索引.png" title>                </div>                <div class="image-caption">innoDB和MyISAM索引.png</div>            </figure><h3 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h3><p>上面说了，二级索引的叶子节点中只存放索引列的值和主键ID，对于非索引列的查找需要回表。这会带来额外的开销。索引覆盖就是说能不能让索引把查找的target字段全部给包含了。</p><p>当发起一个索引覆盖的查询时，EXPLAIN的Extra列可以看到”Using index”信息。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="usingIndex.png" alt="explain.png" title>                </div>                <div class="image-caption">explain.png</div>            </figure><h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>在联合索引中，索引列的顺序对索引的利用率和性能上是有影响的。在一个多列B-Tree索引中，索引列的顺序决定了排序的顺序，越靠左的列排序的优先级越高，也就是说，会先按照第一列排序，在按照第二列排序，以此类推。与此同时，在索引匹配时，是从左往右匹配的。</p><p><strong>所以在建立一个多列的联合索引时应该如何安排索引列的顺序呢？</strong></p><ul><li>最重要的原则就是如果通过调整顺序，可以少维护一个索引，那么这个顺序就是需要优先考虑的。评估的标准就是索引的复用能力。因为支持最左前缀，所以有了(a,b)这个联合索引之后，就不需要在a上建立索引了。</li><li>还有就是考虑空间占用的问题，假如需(name, age)的联合索引，和name和age单独的索引。因为name比age大，所以应该建立(name, age)这个顺序的索引。</li></ul><h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>假设现在有(name,age)联合索引，现在有一个需求：检索出表中名字第一个字是张，而且年龄是10岁的所有男孩</p><p>SQL语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tuser <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'张 %'</span> <span class="keyword">and</span> age=<span class="number">10</span> <span class="keyword">and</span> ismale=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>在这条语句执行时，根据最左前缀匹配原则，这条语句在搜索树的时候只能用到”张“，找到第一个满足条件的记录</p><p>ID3。</p><p>在MySQL 5.6之前，只能从ID3开始一个个回表，到主键索引上找到数据行，再对比字段值。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="索引下推1.jpg" alt="索引下推1.jpg" title>                </div>                <div class="image-caption">索引下推1.jpg</div>            </figure><p>在MySQL 5.6引入了索引下推优化(index condition pushdown)，可以再索引遍历过程中，对索引包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表的次数。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="索引下推2.png" alt="索引下推2.png" title>                </div>                <div class="image-caption">索引下推2.png</div>            </figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于索引的东西还有很多，这篇只是一些非常基础的内容。这篇blog拖了好久了，因为这段时间屁事儿太多了，真的很烦。关于索引的坑以后继续填。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL索引&quot;&gt;&lt;a href=&quot;#MySQL索引&quot; class=&quot;headerlink&quot; title=&quot;MySQL索引&quot;&gt;&lt;/a&gt;MySQL索引&lt;/h1&gt;&lt;p&gt;最近在看数据库索引相关的内容，想写成blog，一来整理一下笔记，二来整理一下思路。&lt;/p&gt;
&lt;p&gt;索
      
    
    </summary>
    
      <category term="MySQL" scheme="https://firecarrrr.github.io/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>终于搭好了</title>
    <link href="https://firecarrrr.github.io/2019/06/15/%E7%BB%88%E4%BA%8E%E6%90%AD%E5%A5%BD%E4%BA%86/"/>
    <id>https://firecarrrr.github.io/2019/06/15/终于搭好了/</id>
    <published>2019-06-15T08:48:18.332Z</published>
    <updated>2019-07-20T08:32:58.136Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="Java" scheme="https://firecarrrr.github.io/categories/Java/"/>
    
    
  </entry>
  
</feed>
