<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YUYUYU&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://firecarrrr.github.io/"/>
  <updated>2020-04-15T14:21:53.481Z</updated>
  <id>https://firecarrrr.github.io/</id>
  
  <author>
    <name>YUYUYU</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Reactor</title>
    <link href="https://firecarrrr.github.io/2020/04/15/Reactor/"/>
    <id>https://firecarrrr.github.io/2020/04/15/Reactor/</id>
    <published>2020-04-15T10:51:16.000Z</published>
    <updated>2020-04-15T14:21:53.481Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Reactor-模式"><a href="#Reactor-模式" class="headerlink" title="Reactor 模式"></a>Reactor 模式</h1><p> NIO 这部分一直迷迷糊糊的，想借学 Reactor 这部分的时候来谈一下。</p><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><p>所谓I/O就是内存和外部设备之间拷贝数据的过程。以网络 I/O为例，也就是用户程序从网卡读取数据和向网卡写数据的过程。这个过程可以被分为两个步骤：</p><ul><li>内核从网卡把数据拷贝到内核缓存</li><li>数据从内核读取到用户程序地址空间</li></ul><p>各种 I/O 模型的区别在于：实现这两个步骤的方式不一样</p><h2 id="同步阻塞-I-O-与-TPC"><a href="#同步阻塞-I-O-与-TPC" class="headerlink" title="同步阻塞 I/O 与 TPC"></a>同步阻塞 I/O 与 TPC</h2><p>TPC 也就是 Thread Per Connection，就是说服务器在处理客户端请求的时候，为每一个客户端分配一个线程去处理。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="tpc.png" alt="tpc.png" title>                </div>                <div class="image-caption">tpc.png</div>            </figure><p>这里之所以需要为每一个请求分配单独的线程是因为 read、write 这些调用都是同步阻塞的。如果单线程，一阻塞，系统就没办法响应新的请求了。</p><p>TPC 的问题在于，创建线程和线程的上下文切换都是需要代价的。面对海量连接，这种模型是无能为力的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionHandler</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Socket socket;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ConnectionHandler</span><span class="params">(Socket socket)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted() &amp;&amp; !socket.isClosed())&#123;</span><br><span class="line">                <span class="comment">// 处理读写事件</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 线程池</span></span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket();</span><br><span class="line">            serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line">            <span class="comment">// 主线程循环等待新连接到来</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                Socket socket = serverSocket.accept();</span><br><span class="line">                <span class="comment">// 把任务提交给线程池</span></span><br><span class="line">                executor.submit(<span class="keyword">new</span> ConnectionHandler(socket));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Reactor-模式-1"><a href="#Reactor-模式-1" class="headerlink" title="Reactor 模式"></a>Reactor 模式</h2><p>TPC 之所以需要创建那么多线程，是因为在执行那些 I/O 操作的时候，并不知道内核是否已经把数据准备好，只能傻等。</p><p>NIO 能够解决这个问题，只需要在 Selector 上注册我们感兴趣的事件（有新连接到来、读就绪、写就绪等）。NIO 能同时监听多个连接，当某条连接上就绪时，操作系统就会通知线程，从阻塞态返回，开始处理。</p><p>Reactor 模式就是利用 NIO 的这种 I/O 多路复用的特性来实现的更高性能的单机高并发模型。Reactor 模式又叫做 Dispatcher 模式，即 I/O 多路复用统一监听事件，收到事件后 Dispatch 给某个线程。</p><p>Reactor 的核心组件包括 Reactor 和处理资源池，典型的配置方案包括：</p><ul><li>单 Reactor / 单线程</li><li>单 Reactor / 多线程</li><li>多 Reactor / 多线程</li></ul><h3 id="单-Reactor-单线程"><a href="#单-Reactor-单线程" class="headerlink" title="单 Reactor / 单线程"></a>单 Reactor / 单线程</h3><p>Redis 就是典型的单 Reactor / 单线程模型</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="oneReactorOneThread.png" alt="单Reactor/单线程.png" title>                </div>                <div class="image-caption">单Reactor/单线程.png</div>            </figure><p>客户端发来请求，Reactor 对象通过 Select 监听到连接事件。收到事件后，如果是建立连接的事件，则交给 Acceptor 处理，Acceptor 通过 accept 接受连接，并创建一个 Handler 处理后续时间。如果不是连接建立时间则调用 Acceptor 中建立的 Handler 来进行响应。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneThreadReactor</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储连接和 Handler 之间的关系</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;SocketChannel, ChannelHandler&gt; handlerHashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>(Selector selector = Selector.open();</span><br><span class="line">            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open())&#123;</span><br><span class="line">            serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line">            <span class="comment">// 设置 channel 为非阻塞</span></span><br><span class="line">            serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 注册到 selector, 设置关注状态</span></span><br><span class="line">            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 阻塞等待就绪的 channel</span></span><br><span class="line">                selector.select();</span><br><span class="line">                <span class="comment">// 获取所有就绪的 channel</span></span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    SelectionKey key = iterator.next();</span><br><span class="line">                    <span class="comment">// 接受连接并注册 handler</span></span><br><span class="line">                    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">                        registerHandler((ServerSocketChannel) key.channel(), selector);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 调用连接对应 Handler 处理读事件</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable()) &#123;</span><br><span class="line">                        getHandler((SocketChannel) key.channel()).channelReadable();</span><br><span class="line">                    &#125;</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接受连接并绑定处理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serverSocketChannel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerHandler</span><span class="params">(ServerSocketChannel serverSocketChannel, Selector selector)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">            socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">            handlerHashMap.put(socketChannel, <span class="keyword">new</span> ChannelHandler(socketChannel));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取绑定的 handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> socketChannel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ChannelHandler <span class="title">getHandler</span><span class="params">(SocketChannel socketChannel)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handlerHashMap.get(socketChannel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OneThreadReactor server = <span class="keyword">new</span> OneThreadReactor();</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单 Reactor / 单线程模型没有线程的切换，确实效率非常高，但是也有它的局限性。第一是不能利用多核能力。第二是应用场景有限，只适合处理速度非常快的场景，如果处理逻辑里有访问数据库等耗时操作，整个服务器就卡住了。</p><h3 id="单-Reactor-多线程"><a href="#单-Reactor-多线程" class="headerlink" title="单 Reactor / 多线程"></a>单 Reactor / 多线程</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="oneReactorMuiltyThread.png" alt="单Reactor/多线程.png" title>                </div>                <div class="image-caption">单Reactor/多线程.png</div>            </figure><p>和单 Reactor / 单线程的区别是，Handler 不会负责业务处理，Handler 通过 read 读取到数据后，会发送给 Processor 进行业务处理。业务处理完成之后，会将结果发给主线程中的 send 将相应结果返回给 client。</p><h3 id="多-Reactor-多线程"><a href="#多-Reactor-多线程" class="headerlink" title="多 Reactor / 多线程"></a>多 Reactor / 多线程</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="muiltyRactor.png" alt="多Reactor/多线程.png" title>                </div>                <div class="image-caption">多Reactor/多线程.png</div>            </figure><p>父线程只监听连接的建立事件，当出现连接建立事件后 Acceptor 接受连接，并将新连接分配给某个子线程。子线程将监听连接，并创建一个对应的 Handler。当事件发生后，子线程调用 Handler 来做相应。</p><p>Ngnix（具体实现上有差异）、Netty 就是采用这种模型。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Reactor-模式&quot;&gt;&lt;a href=&quot;#Reactor-模式&quot; class=&quot;headerlink&quot; title=&quot;Reactor 模式&quot;&gt;&lt;/a&gt;Reactor 模式&lt;/h1&gt;&lt;p&gt; NIO 这部分一直迷迷糊糊的，想借学 Reactor 这部分的时候来谈一下
      
    
    </summary>
    
      <category term="Java" scheme="https://firecarrrr.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL事务隔离和MVCC</title>
    <link href="https://firecarrrr.github.io/2019/08/04/mysql-transaction/"/>
    <id>https://firecarrrr.github.io/2019/08/04/mysql-transaction/</id>
    <published>2019-08-04T08:25:20.000Z</published>
    <updated>2019-08-24T14:44:13.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL事务隔离和MVCC"><a href="#MySQL事务隔离和MVCC" class="headerlink" title="MySQL事务隔离和MVCC"></a>MySQL事务隔离和MVCC</h1><p>同样，把最近看的事务和锁的部分总结一下，这部分的确东西蛮多的。</p><h2 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h2><p>其实事务这东西说白了就是一组操作的集合。我们希望数据库系统能够保证这一组操作数据一致且操作独立。数据一致就是说事务在提交的时候保证事务内的所有操作都能成功完成，并且永久生效。操作独立是说多个同时执行的事务之间应该是相互独立，互不影响的。</p><p>用标准一点的说法，还就是老生常谈的ACID，感觉ACID更像是目标吧，真实的系统不一定能实现：</p><ul><li><p><strong>原子性（atomicity）：</strong>这个最好理解，就是说一个事务的所有操作是不可分隔的最小工作单元，要么全部成功，要么全部失败。</p></li><li><p><strong>一致性（consistency）：</strong>数据库总是从一个一致性状态转换到另一个一致性状态。在任何时刻，包括数据库正常提供服务的时候，数据库从异常中恢复过来的时候，数据都是一致的，保证不会读到中间状态的数据。每本数据库书里都会举的转账的例子，A转200块给B的这个转账的事务执行后，A的钱少了200，B的钱就一定会多200。数据库不会因为这个事务的执行，出现逻辑上不一致的状况。</p></li><li><p><strong>隔离性（isolation）：</strong>所有事情当出现在并发的场景下都会变得复杂。通常来说，一个事务所做的修改在最终提交之前，对其他事务是不可见的。在真实地数据库系统中，不尽然是这样的，可以通过设置不同的<strong>隔离级别（isolation level）</strong>来调整不同事务操作对彼此的可见性。</p></li><li><p><strong>持久性（durability）：</strong>一旦事务提交，其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。</p></li></ul><p>并不是所有存储引擎都支持事务，比如MyISAM就不支持事务。</p><h3 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h3><p>当数据库中有多个事务同时执行的时候，如果不加控制，就会出现各种各样的问题：</p><ul><li><p><strong>脏读（dirty read）：</strong>当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中的时候，另一个事务也访问了这个数据<strong>（脏数据）</strong>。</p></li><li><p><strong>不可重复读（non-repeatable read）：</strong>是指在一个事务中，多次读同一个数据。两次读取之间，另一个事务修改了数据，造成第一个事务两次读取数据不一致的情况。</p></li><li><p><strong>幻读（phantom read）：</strong>当保证了可重复读后，事务进行过程中查询的结果都是事务开始时的状态。但是如果另一个事务提交了数据，本事务再更新时，就可能会出现错误，就好像之前读到的数据是“鬼影”一样的幻觉似的。比如，第一个事务对一个表中的数据进行了修改或读取，这种修改或读取涉及到表中所有的数据行。同时，第二个事务向表中插入了一行新数据，就会发生第一个事务发现有行没有被修改的情况。</p></li></ul><p>为了解决这些问题，就有了<strong>隔离级别</strong>的概念，SQL的标准隔离级别有：</p><ul><li><p><strong>读未提交（read uncommitted）：</strong>一个事务还没提交时，它做的变更就能被其它事务看到（这不就相当于没隔离吗），所有的问题都可能发生。</p></li><li><p><strong>读提交（read committed）：</strong>一个事务提交之后，它做的变更才能被其它事务看到。读提交可以解决脏读的问题。</p></li><li><p><strong>可重复读（repeatable read）：</strong>一个事务在执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。可重复读解决了脏读和不可重复读的问题但是没有解决幻读的问题。可重复读是MySQL的<strong>默认事务隔离级别</strong>。</p></li><li><p><strong>串行化（serializable）：</strong>强制让事务串行执行，最高的隔离级别。</p></li></ul><p>随着隔离级别的提升，出现并发问题的可能性在减小，可是并发性能也在降低。很多时候都是个权衡的问题。</p><h2 id="多版本并发控制——MVCC"><a href="#多版本并发控制——MVCC" class="headerlink" title="多版本并发控制——MVCC"></a>多版本并发控制——MVCC</h2><p>MVCC是一种提高并发的技术。在最早的数据库系统中，只有读读之间可以并发，读写，写读，写写都是要阻塞的。引入MVCC之后，只有写写之间是相互阻塞的，其它三种操作都可以并行，大幅提高了InnoDB的并发度。在多事务环境下，对数据读写在不加读写锁的情况下实现互补干扰，<strong>从而实现了数据库的隔离性</strong>。</p><h3 id="MVCC的实现"><a href="#MVCC的实现" class="headerlink" title="MVCC的实现"></a>MVCC的实现</h3><h4 id="Undo-Log"><a href="#Undo-Log" class="headerlink" title="Undo Log"></a>Undo Log</h4><p>undo log主要用于存放数据被修改前的值。undo log分为两类，一种是INSERT_UNDO，记录插入的唯一键值；一种是UPDATE_UNDO，包括UPDATE及DELETE操作，记录修改的唯一键值以及old column记录。undo log主要由两个作用：</p><ul><li>事务回滚</li><li>MVCC多版本控制</li></ul><p>InnoDB以聚簇索引的方式存储数据，MySQL默认为每个索引添加了4个隐藏的字段。</p><p>其中</p><ul><li><strong>DB_ROLL_PTR</strong>：是undo log的指针，用于记录之前的历史数据在undo log中的位置。undo log中的历史数据行中的<code>DB_ROLL_PTR</code>指向的是上一次修改的行的undo log。这样多次更新后，回滚指针会把不同的版本的记录串在一起。</li><li><strong>DB_ROW_ID</strong>：是如果没有定义主键和合适的键做主键的时候，MySQL自己生成的一个隐藏的主键。</li><li><strong>DB_TRX_ID</strong>：是最近更改改行数据的事务ID。</li><li><strong>DELETE_BIT</strong>：是索引删除标志，如果DB删除了一条数据，是优先通知索引将这个标志位设置为1，然后通过清除线程去异步删除真实的数据</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="mvcc3.png" alt="索引隐藏字段.png" title>                </div>                <div class="image-caption">索引隐藏字段.png</div>            </figure><p>整个innoDB的MVCC机制都是通过<code>DB_ROLL_PTR</code>和<code>DB_TRX_ID</code>这两个字段实现的。</p><h4 id="Read-View"><a href="#Read-View" class="headerlink" title="Read View"></a>Read View</h4><p>由于undo log的存在，数据的多个版本得以保存。这就给事务隔离的实现创造了条件，对于RR和RC隔离级别的事务，对数据进行访问之前都需要对数据的可见性进行判断，也就是说需要判断当前事务是否能看到这一行数据，看到的应该是哪个版本的数据。这些功能的实现依赖于Read View对象。</p><p>首先，当一个事务开始的时候，会将当前数据库中正在活跃的所有事务（执行begin，但是还没有commit的事务）保存到一个叫做<code>trx_sys</code>的事务链表中，事务链表中保存的都是未提交的事务，当事务提交之后会从中删除。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="trx_sys.png" alt="活跃事务链表.png" title>                </div>                <div class="image-caption">活跃事务链表.png</div>            </figure><p>Read View的初始化相当于给当前的<code>trx_sys</code> 打一个快照。</p><ul><li>活跃事务链表(<code>trx_sys</code>)中事务id最大的值被赋值给<code>m_low_limit_id</code>。</li><li>活跃事务链表中第一个值(也就是事务id最小)被赋值给<code>m_up_limit_id</code>。</li><li><code>m_ids</code> 为事务链表。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// readview 初始化</span></span><br><span class="line"><span class="comment">// m_low_limit_id = trx_sys-&gt;max_trx_id; </span></span><br><span class="line"><span class="comment">// m_up_limit_id = !m_ids.empty() ? m_ids.front() : m_low_limit_id;</span></span><br><span class="line">ReadView::ReadView()</span><br><span class="line">    :</span><br><span class="line">    m_low_limit_id(),</span><br><span class="line">    m_up_limit_id(),</span><br><span class="line">    m_creator_trx_id(),</span><br><span class="line">    m_ids(),</span><br><span class="line">    m_low_limit_no()</span><br><span class="line">&#123;</span><br><span class="line">    ut_d(::<span class="built_in">memset</span>(&amp;m_view_list, <span class="number">0x0</span>, <span class="keyword">sizeof</span>(m_view_list)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个Read View，事务就可以根据查询到的所有记录的<code>DB_TRX_ID</code>来匹配是否能看见该记录。</p><ul><li>当检索到的数据的事务ID(数据事务ID &lt; <code>m_up_limit_id</code>) 小于事务链表中的最小值表示这个数据在当前事务开启前就已经被其他事务修改过了,所以是可见的。</li><li>当检索到的数据的事务ID(数据事务ID = <code>m_creator_trx_id</code>) 表示是当前事务自己修改的数据。</li><li>当检索到的数据的事务ID(数据事务ID &gt;= <code>m_low_limit_id</code>) 大于事务链表中的最大值表示这个数据在当前事务开启之前又被其他的事务修改过,那么就是不可见的。</li><li>如果事务ID落在(<code>m_up_limit_id</code>,<code>m_low_limit_id</code>)，需要在活跃读写事务数组查找事务ID是否存在，如果存在，记录对于当前read view是不可见的。</li></ul><p><strong>如果记录对于view不可见，需要通过记录的<code>DB_ROLL_PTR</code>指针遍历history list构造当前view可见版本数据</strong>。</p><p>上面基本上是对于聚簇索引的情况，对于二级索引，在二级索引页中存储了更新当前页的最大事务ID，<strong>如果该事务ID大于read view中的<code>m_up_limit_id</code>，那么就需要回聚簇索引判断记录可见性。</strong></p><p>RR隔离级别（除了Gap锁之外）和RC隔离级别的差别是创建read view的时机不同。<strong>RR隔离级别是在事务开始时刻，确切地说是第一个读操作创建read view的；RC隔离级别是在语句开始时刻创建read view的。</strong></p><p><strong>undo log什么时候会被删除呢？</strong></p><p>当该undo log关联的事务没有出现在其他事务的read view中时(事务已提交，且没有其他事务依赖当前事务)，那么InnoDB引擎的后台清除线程(purge线程)会进行遍历删除undo log操作。</p><p>因此长事务会导致数据库中存在大量的undo log，占用大量的存储空间。所以<strong>应该尽量避免长事务</strong>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一个月一篇的速度真的是醉了。。。未完待续</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL事务隔离和MVCC&quot;&gt;&lt;a href=&quot;#MySQL事务隔离和MVCC&quot; class=&quot;headerlink&quot; title=&quot;MySQL事务隔离和MVCC&quot;&gt;&lt;/a&gt;MySQL事务隔离和MVCC&lt;/h1&gt;&lt;p&gt;同样，把最近看的事务和锁的部分总结一下，这部
      
    
    </summary>
    
      <category term="MySQL" scheme="https://firecarrrr.github.io/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL索引（一）</title>
    <link href="https://firecarrrr.github.io/2019/07/20/mysql-index/"/>
    <id>https://firecarrrr.github.io/2019/07/20/mysql-index/</id>
    <published>2019-07-20T09:11:18.000Z</published>
    <updated>2019-07-20T09:20:21.078Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h1><p>最近在看数据库索引相关的内容，想写成blog，一来整理一下笔记，二来整理一下思路。</p><p>索引的目的是加快数据访问的速度，要实现这个目的需要用到一些高效的数据结构。索引是在存储引擎层实现的，不同的存储引擎可能采用不同的实现方式，用到的数据结构也不尽相同。</p><h2 id="索引的数据结构基础"><a href="#索引的数据结构基础" class="headerlink" title="索引的数据结构基础"></a>索引的数据结构基础</h2><h3 id="B-Tree和B-Tree"><a href="#B-Tree和B-Tree" class="headerlink" title="B-Tree和B+ Tree"></a>B-Tree和B+ Tree</h3><p>MySQL的默认存储引擎InnoDB使用B+ Tree来实现索引，B+ Tree是B-Tree的一个变种，基本上大部分存储引擎都是使用B-Tree类的数据结构来实现索引的。</p><p><strong>为什么要用B-Tree或者B-Tree产生的动机是什么？</strong></p><p>B-Tree本质上是二叉搜索树的一个推广，每一个B-Tree内部节点x有x.n个关键字，这x.n个关键字从小到大依次排列，把关键字分成了x.n+1个区间，那么x就有x.n+1个孩子节点分别存储这些区间范围内的关键字。由于n的数值可以很大，所以B-Tree的树高可以很低，树高低就意味着找到目标需要的随机IO次数少。n的值取多少合适呢？</p><p>我们存储在数据库里的数据，是存储在磁盘上的（也有可能是SSD啦，不过很贵吧），磁盘作为一种依靠磁臂在不同磁道和扇区之间机械运动读取数据的存储装置，与内存和CPU相比就很慢。要加快数据的访问速度那就要减少磁盘IO的次数。磁盘本身存储数据的最小单位是扇区（一般为512 byte），而操作系统的文件系统不是以扇区为单位来读取磁盘的，因为这太慢了，所以有了block（块）的概念，它是一个块一个块的读取的，如果要读取的数据超过一块就会触发多次IO，一个块的大小一般是4K byte。</p><p>一个B-Tree算法的运行时间主要由它执行磁盘读写的时间决定，所以，一个B-Tree节点的大小通常和一个完整的块的大小一样大。因此，磁盘块的大小限制了B-Tree节点可以含有的孩子个数。</p><p>B+ Tree是B-Tree的一个常见变种，B+Tree把所有的卫星数据（除作为键值外的其他数据）都存储在叶子节点里，也就是说非叶节点只存储键值和孩子指针，并且叶子节点之间用指针连接。</p><p><strong>B-Tree由于它的有序性，所以增删节点，维护起来会耗费额外的资源</strong></p><p><strong>所以索引会提高查询效率，但是会降低写入和删除的效率</strong></p><h3 id="Hash表"><a href="#Hash表" class="headerlink" title="Hash表"></a>Hash表</h3><p>hash表没啥可说的，key-value存储方式。需要注意的是，由于hash索引不会按键值顺序存储，所以<strong>hash索引只适用于等值查询的场景，做区间查询会很慢，也没法做部分匹配。</strong></p><h2 id="索引的细节"><a href="#索引的细节" class="headerlink" title="索引的细节"></a>索引的细节</h2><p>下面关于索引的讨论基本上都是针对于MySQL默认存储引擎InnoDB而言的。</p><h3 id="聚簇索引与二级索引"><a href="#聚簇索引与二级索引" class="headerlink" title="聚簇索引与二级索引"></a>聚簇索引与二级索引</h3><p>对于InnoDB而言，聚簇索引其实就是主键索引，在索引的叶子节点中，存储了包含全部数据的数据行。<strong>“聚簇”的意思是说数据行和相邻键值的数据行紧凑的存储在一起（并非一直成立）。</strong></p><p>聚簇索引的实现同样依赖于存储引擎，并非所有存储引擎都支持聚簇索引。聚簇索引的优点显而易见，聚簇索引可以最大限度的提高IO密集型应用的性能。但是这种使用这种精巧的数据结构存储数据都会面临维护上的开销。对于聚簇索引来说：</p><ul><li><p><strong>插入新数据行的速度严重依赖于插入顺序。</strong>按照主键顺序插入到InnoDB表中速度肯定是最快的，非顺序插入不仅慢而且会导致很多磁盘碎片的产生。所以一般尽量用自增主键做主键值，这样在性能上和存储空间上都有优势。</p></li><li><p><strong>更新主键的代价很大。</strong>因为是数据行按主键顺序紧密存储的，所以更新主键就会带来数据行的移动。</p></li><li><p><strong>插入新行（乱序）、主键更新需要移动行时，都可能面临“页分裂（page split）”问题。</strong>当需要把一行插入到一个已满页面的时候，存储引擎会把这个页分裂成两个页来容纳这个行，页分裂操作会导致占用更多磁盘空间，空间利用率降低。</p></li><li><p><strong>聚簇索引会让全表扫描变慢，尤其是行比较稀疏的时候，或者由于页分裂导致数据存储不连续的时候。</strong>这应该是和把所有数据行直接连续存储相比而言的。</p></li></ul><p>二级索引就是指非主键索引，二级索引的叶子节点中除了存储索引列的值之外，还存储了对应行的主键值。这是与MyISAM存储引擎的一个明显的不同，MyISAM索引的叶子节点中存储的时指向数据行的行指针（MyISAM存储引擎按照数据的插入顺序，将数据行存储在磁盘上）。</p><p>InnoDB这种存储主键的方式带来了一个显而易见的好处就是<strong>减少了出现行移动或者数据页分裂时二级索引的维护工作。</strong>也带来了一个显而易见的坏处就是<strong>使用二级索引查询索引不能覆盖的列信息时，需要再到主键索引表回表查询一次。</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="索引对比.png" alt="innoDB和MyISAM索引.png" title>                </div>                <div class="image-caption">innoDB和MyISAM索引.png</div>            </figure><h3 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h3><p>上面说了，二级索引的叶子节点中只存放索引列的值和主键ID，对于非索引列的查找需要回表。这会带来额外的开销。索引覆盖就是说能不能让索引把查找的target字段全部给包含了。</p><p>当发起一个索引覆盖的查询时，EXPLAIN的Extra列可以看到”Using index”信息。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="usingIndex.png" alt="explain.png" title>                </div>                <div class="image-caption">explain.png</div>            </figure><h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>在联合索引中，索引列的顺序对索引的利用率和性能上是有影响的。在一个多列B-Tree索引中，索引列的顺序决定了排序的顺序，越靠左的列排序的优先级越高，也就是说，会先按照第一列排序，在按照第二列排序，以此类推。与此同时，在索引匹配时，是从左往右匹配的。</p><p><strong>所以在建立一个多列的联合索引时应该如何安排索引列的顺序呢？</strong></p><ul><li>最重要的原则就是如果通过调整顺序，可以少维护一个索引，那么这个顺序就是需要优先考虑的。评估的标准就是索引的复用能力。因为支持最左前缀，所以有了(a,b)这个联合索引之后，就不需要在a上建立索引了。</li><li>还有就是考虑空间占用的问题，假如需(name, age)的联合索引，和name和age单独的索引。因为name比age大，所以应该建立(name, age)这个顺序的索引。</li></ul><h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>假设现在有(name,age)联合索引，现在有一个需求：检索出表中名字第一个字是张，而且年龄是10岁的所有男孩</p><p>SQL语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tuser <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'张 %'</span> <span class="keyword">and</span> age=<span class="number">10</span> <span class="keyword">and</span> ismale=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>在这条语句执行时，根据最左前缀匹配原则，这条语句在搜索树的时候只能用到”张“，找到第一个满足条件的记录</p><p>ID3。</p><p>在MySQL 5.6之前，只能从ID3开始一个个回表，到主键索引上找到数据行，再对比字段值。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="索引下推1.jpg" alt="索引下推1.jpg" title>                </div>                <div class="image-caption">索引下推1.jpg</div>            </figure><p>在MySQL 5.6引入了索引下推优化(index condition pushdown)，可以再索引遍历过程中，对索引包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表的次数。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="索引下推2.png" alt="索引下推2.png" title>                </div>                <div class="image-caption">索引下推2.png</div>            </figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于索引的东西还有很多，这篇只是一些非常基础的内容。这篇blog拖了好久了，因为这段时间屁事儿太多了，真的很烦。关于索引的坑以后继续填。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL索引&quot;&gt;&lt;a href=&quot;#MySQL索引&quot; class=&quot;headerlink&quot; title=&quot;MySQL索引&quot;&gt;&lt;/a&gt;MySQL索引&lt;/h1&gt;&lt;p&gt;最近在看数据库索引相关的内容，想写成blog，一来整理一下笔记，二来整理一下思路。&lt;/p&gt;
&lt;p&gt;索
      
    
    </summary>
    
      <category term="MySQL" scheme="https://firecarrrr.github.io/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>终于搭好了</title>
    <link href="https://firecarrrr.github.io/2019/06/15/%E7%BB%88%E4%BA%8E%E6%90%AD%E5%A5%BD%E4%BA%86/"/>
    <id>https://firecarrrr.github.io/2019/06/15/终于搭好了/</id>
    <published>2019-06-15T08:48:18.332Z</published>
    <updated>2019-07-20T08:32:58.136Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="Java" scheme="https://firecarrrr.github.io/categories/Java/"/>
    
    
  </entry>
  
</feed>
